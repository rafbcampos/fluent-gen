// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`FluentGen > complex types > should generate builder for ComplexType with various property types 1`] = `
{
  "ok": true,
  "value": "
/**
 * Runtime utilities for fluent builders
 * Core functionality for builder pattern implementation
 */

/**
 * Unique symbol for identifying fluent builders
 * Used across module boundaries for proper type identification
 */
const FLUENT_BUILDER_SYMBOL = Symbol.for("fluent-builder");

/**
 * Base context interface for builder operations
 * Provides information about the builder's position in the object hierarchy
 */
interface BaseBuildContext {
  /** Parent builder identifier */
  readonly parentId?: string;
  /** Name of the parameter being built */
  readonly parameterName?: string;
  /** Index in array if building array elements */
  readonly index?: number;
  /** Additional context properties */
  readonly [key: string]: unknown;
}

/**
 * Core fluent builder interface
 * All generated builders implement this interface
 */
interface FluentBuilder<T, C extends BaseBuildContext = BaseBuildContext> {
  /** Identifies this as a fluent builder */
  readonly [FLUENT_BUILDER_SYMBOL]: true;
  /**
   * Builds the final object
   * @param context - Optional build context
   */
  build(context?: C): T;
}

/**
 * Type guard to check if a value is a fluent builder
 * Uses Symbol.for to ensure proper identification across module boundaries
 * @param value - Value to check
 * @returns True if value is a fluent builder
 */
function isFluentBuilder<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is FluentBuilder<T, C> {
  if (value === null || typeof value !== "object") {
    return false;
  }

  // Safely check for symbol property
  const hasSymbol = FLUENT_BUILDER_SYMBOL in value;
  if (!hasSymbol) {
    return false;
  }

  // Type narrowing: at this point we know it's an object with our symbol
  const obj = value as { [FLUENT_BUILDER_SYMBOL]: unknown; build?: unknown };

  return (
    obj[FLUENT_BUILDER_SYMBOL] === true &&
    typeof obj.build === "function"
  );
}

/**
 * Type guard to check if a value is a builder array
 * @param value - Value to check
 * @returns True if value is an array of builders
 */
function isBuilderArray<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is Array<FluentBuilder<T, C>> {
  return Array.isArray(value) && value.every(isFluentBuilder);
}

/**
 * Creates a new context for nested builders with proper inheritance
 * @param parentContext - Context from parent builder
 * @param parameterName - Name of the parameter being built
 * @param index - Optional array index
 * @returns New context with inherited properties
 */
function createNestedContext<C extends BaseBuildContext>(
  parentContext: C,
  parameterName: string,
  index?: number,
): C {
  return {
    ...parentContext,
    parameterName,
    index,
  } as C;
}

/**
 * Recursively resolves builders in a value
 * @param value - Value to resolve
 * @param context - Optional build context
 * @returns Resolved value with all builders built
 */
function resolveValue<T, C extends BaseBuildContext>(
  value: unknown,
  context?: C
): unknown {
  if (isFluentBuilder<T, C>(value)) {
    return value.build(context);
  }

  if (Array.isArray(value)) {
    return value.map((item, index) => {
      const arrayContext = context ? createNestedContext(context, 'array', index) : undefined;
      return resolveValue(item, arrayContext);
    });
  }

  if (value && typeof value === 'object' && value.constructor === Object) {
    const resolved: Record<string, unknown> = {};
    for (const [key, val] of Object.entries(value)) {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      resolved[key] = resolveValue(val, nestedContext);
    }
    return resolved;
  }

  return value;
}

/**
 * Base class for all generated builders
 * Provides core functionality for the builder pattern
 */
abstract class FluentBuilderBase<T, C extends BaseBuildContext = BaseBuildContext> {
  /** Marks this as a fluent builder */
  readonly [FLUENT_BUILDER_SYMBOL] = true;
  /** Storage for property values */
  protected values: Partial<T> = {};
  /** Storage for nested builders - includes indexed keys for array elements */
  protected builders = new Map<string, FluentBuilder<unknown, C> | unknown>();
  /** Storage for mixed arrays (static values + builders) */
  protected mixedArrays = new Map<string, unknown[]>();
  /** Optional build context */
  protected context?: C;

  /**
   * Creates a new builder instance
   * @param initial - Optional initial values
   */
  constructor(initial?: Partial<T>) {
    if (initial) {
      this.values = { ...initial };
    }
  }

  /**
   * Sets a property value, handling both regular values and nested builders
   * @param key - The property key
   * @param value - The value or builder to set
   */
  protected set<K extends keyof T>(key: K, value: unknown): this {
    const keyStr = String(key);

    if (isFluentBuilder(value)) {
      this.builders.set(keyStr, value);
      // Clear from values if it was there
      delete this.values[key];
    } else if (Array.isArray(value)) {
      // Handle mixed arrays (builders + static values)
      const hasBuilders = value.some((item) => isFluentBuilder(item) ||
        (typeof item === 'object' && item !== null && this.containsBuilder(item)));

      if (hasBuilders) {
        // Store the array for mixed processing
        this.mixedArrays.set(keyStr, value);
        // Store individual builders with indexed keys
        value.forEach((item, index) => {
          if (isFluentBuilder(item)) {
            this.builders.set(\`\${keyStr}[\${index}]\`, item);
          } else if (typeof item === 'object' && item !== null && this.containsBuilder(item)) {
            // Store objects containing builders for recursive resolution
            this.builders.set(\`\${keyStr}[\${index}]\`, item);
          }
        });
        // Clear from values
        delete this.values[key];
      } else {
        // Pure static array
        this.values[key] = value as T[K];
        // Clear from mixed arrays if it was there
        this.mixedArrays.delete(keyStr);
      }
    } else if (typeof value === 'object' && value !== null && this.containsBuilder(value)) {
      // Object containing builders
      this.builders.set(keyStr, value);
      delete this.values[key];
    } else {
      // Static value
      this.values[key] = value as T[K];
      // Clear from builders if it was there
      this.builders.delete(keyStr);
      this.mixedArrays.delete(keyStr);
    }
    return this;
  }

  /**
   * Checks if an object contains any builders recursively
   */
  private containsBuilder(obj: unknown): boolean {
    if (isFluentBuilder(obj)) return true;
    if (Array.isArray(obj)) {
      return obj.some((item) => this.containsBuilder(item));
    }
    if (obj && typeof obj === 'object' && obj.constructor === Object) {
      return Object.values(obj).some((val) => this.containsBuilder(val));
    }
    return false;
  }

  /**
   * Builds the final object with defaults and nested builder resolution
   * @param defaults - Optional default values
   * @param context - Optional build context
   */
  protected buildWithDefaults(defaults?: Partial<T>, context?: C): T {
    const result: Record<string, unknown> = defaults ? { ...defaults } : {};

    // Apply explicitly set values
    Object.assign(result, this.values);

    // Process mixed arrays
    this.mixedArrays.forEach((array, key) => {
      const resolvedArray: unknown[] = [];
      array.forEach((item, index) => {
        const indexedKey = \`\${key}[\${index}]\`;
        const nestedContext = context ? createNestedContext(context, key, index) : undefined;

        // Check if this index has a builder stored
        if (this.builders.has(indexedKey)) {
          const builderOrObj = this.builders.get(indexedKey);
          resolvedArray[index] = resolveValue(builderOrObj, nestedContext);
        } else {
          // Static value
          resolvedArray[index] = item;
        }
      });
      result[key] = resolvedArray;
    });

    // Process regular builders (non-array)
    this.builders.forEach((value, key) => {
      // Skip indexed keys (they're handled in mixed arrays)
      if (key.includes('[')) return;
      // Skip keys that are in mixed arrays
      if (this.mixedArrays.has(key)) return;

      const nestedContext = context ? createNestedContext(context, key) : undefined;
      result[key] = resolveValue(value, nestedContext);
    });

    // Type assertion is safe here as we're building from typed values
    return result as T;
  }

  /**
   * Conditionally sets a property based on a predicate
   * @param predicate - Function to determine if the property should be set
   * @param property - The property key
   * @param value - The value or value generator
   */
  public if<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    value: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>)
  ): this {
    if (predicate(this)) {
      // Type guard: check if it's a function that's not a builder
      const resolvedValue = typeof value === 'function' && !isFluentBuilder(value)
        ? (value as () => T[K] | FluentBuilder<T[K], C>)()
        : value;
      this.set(property, resolvedValue);
    }
    return this;
  }

  /**
   * Conditionally sets a property choosing between two values
   * @param predicate - Function to determine which value to use
   * @param property - The property key
   * @param trueValue - Value to use if predicate is true
   * @param falseValue - Value to use if predicate is false
   */
  public ifElse<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    trueValue: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>),
    falseValue: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>)
  ): this {
    const valueToUse = predicate(this) ? trueValue : falseValue;
    // Type guard: check if it's a function that's not a builder
    const resolvedValue = typeof valueToUse === 'function' && !isFluentBuilder(valueToUse)
      ? (valueToUse as () => T[K] | FluentBuilder<T[K], C>)()
      : valueToUse;
    this.set(property, resolvedValue);
    return this;
  }

  /**
   * Checks if a property has been set
   * @param key - The property key to check
   */
  public has<K extends keyof T>(key: K): boolean {
    const keyStr = String(key);
    return key in this.values || this.builders.has(keyStr) || this.mixedArrays.has(keyStr);
  }

  /**
   * Get current value (useful for conditional logic)
   * @param key - The property key
   * @returns The current value or undefined
   */
  public peek<K extends keyof T>(key: K): T[K] | undefined {
    return this.values[key];
  }

  /**
   * Abstract build method to be implemented by generated builders
   * @param context - Optional build context
   */
  abstract build(context?: C): T;
}

/**
 * Creates an inspect method for better debugging experience
 * @param builderName - Name of the builder class
 * @param properties - Current builder properties
 * @returns Formatted string for inspection
 */
function createInspectMethod(builderName: string, properties: Record<string, unknown>): string {
  return \`\${builderName} { properties: \${JSON.stringify(properties, null, 2)} }\`;
}


import type { ComplexType } from "./src/__tests__/fixtures/simple.ts";

export interface ComplexTypeBuilderMethods {
  withUnion(value: string | number | undefined | undefined): ComplexTypeBuilder;
  withIntersection(value: User & object): ComplexTypeBuilder;
  withArray(value: Array<string>): ComplexTypeBuilder;
  withTuple(value: [string, number, boolean]): ComplexTypeBuilder;
  withLiteral(value: "foo" | "bar" | 42): ComplexTypeBuilder;
  withNested(value: object): ComplexTypeBuilder;
}

export class ComplexTypeBuilder extends FluentBuilderBase<ComplexType> implements ComplexTypeBuilderMethods, FluentBuilder<ComplexType, BaseBuildContext> {
  private static readonly defaults: Record<string, unknown> = { union: "", intersection: { id: "", name: "", address: { street: "", city: "", country: "" }, role: "" }, array: [""], tuple: ["", 0, false], literal: "foo", nested: { deep: { value: "" } } };

  constructor(initial?: Partial<ComplexType>) {
    super(initial);
  }


  withUnion(value: string | number | undefined | undefined): ComplexTypeBuilder {
    return this.set("union", value);
  }


  withIntersection(value: User & object): ComplexTypeBuilder {
    return this.set("intersection", value);
  }


  withArray(value: Array<string>): ComplexTypeBuilder {
    return this.set("array", value);
  }


  withTuple(value: [string, number, boolean]): ComplexTypeBuilder {
    return this.set("tuple", value);
  }


  withLiteral(value: "foo" | "bar" | 42): ComplexTypeBuilder {
    return this.set("literal", value);
  }


  withNested(value: object): ComplexTypeBuilder {
    return this.set("nested", value);
  }

  /**
   * Builds the final ComplexType object
   * @param context - Optional build context for nested builders
   */
  build(context?: BaseBuildContext): ComplexType {
    return this.buildWithDefaults(ComplexTypeBuilder.defaults, context);
  }

  [Symbol.for("nodejs.util.inspect.custom")](): string {
    return createInspectMethod("ComplexTypeBuilder", this.values);
  }
}

/**
 * Creates a new ComplexType builder
 * @param initial Optional initial values
 * @returns A fluent builder for ComplexType
 */
export function complexType(initial?: Partial<ComplexType>): ComplexTypeBuilder {
  return new ComplexTypeBuilder(initial);
}",
}
`;

exports[`FluentGen > complex types > should generate builder for Result union type 1`] = `
{
  "ok": true,
  "value": "
/**
 * Runtime utilities for fluent builders
 * Core functionality for builder pattern implementation
 */

/**
 * Unique symbol for identifying fluent builders
 * Used across module boundaries for proper type identification
 */
const FLUENT_BUILDER_SYMBOL = Symbol.for("fluent-builder");

/**
 * Base context interface for builder operations
 * Provides information about the builder's position in the object hierarchy
 */
interface BaseBuildContext {
  /** Parent builder identifier */
  readonly parentId?: string;
  /** Name of the parameter being built */
  readonly parameterName?: string;
  /** Index in array if building array elements */
  readonly index?: number;
  /** Additional context properties */
  readonly [key: string]: unknown;
}

/**
 * Core fluent builder interface
 * All generated builders implement this interface
 */
interface FluentBuilder<T, C extends BaseBuildContext = BaseBuildContext> {
  /** Identifies this as a fluent builder */
  readonly [FLUENT_BUILDER_SYMBOL]: true;
  /**
   * Builds the final object
   * @param context - Optional build context
   */
  build(context?: C): T;
}

/**
 * Type guard to check if a value is a fluent builder
 * Uses Symbol.for to ensure proper identification across module boundaries
 * @param value - Value to check
 * @returns True if value is a fluent builder
 */
function isFluentBuilder<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is FluentBuilder<T, C> {
  if (value === null || typeof value !== "object") {
    return false;
  }

  // Safely check for symbol property
  const hasSymbol = FLUENT_BUILDER_SYMBOL in value;
  if (!hasSymbol) {
    return false;
  }

  // Type narrowing: at this point we know it's an object with our symbol
  const obj = value as { [FLUENT_BUILDER_SYMBOL]: unknown; build?: unknown };

  return (
    obj[FLUENT_BUILDER_SYMBOL] === true &&
    typeof obj.build === "function"
  );
}

/**
 * Type guard to check if a value is a builder array
 * @param value - Value to check
 * @returns True if value is an array of builders
 */
function isBuilderArray<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is Array<FluentBuilder<T, C>> {
  return Array.isArray(value) && value.every(isFluentBuilder);
}

/**
 * Creates a new context for nested builders with proper inheritance
 * @param parentContext - Context from parent builder
 * @param parameterName - Name of the parameter being built
 * @param index - Optional array index
 * @returns New context with inherited properties
 */
function createNestedContext<C extends BaseBuildContext>(
  parentContext: C,
  parameterName: string,
  index?: number,
): C {
  return {
    ...parentContext,
    parameterName,
    index,
  } as C;
}

/**
 * Recursively resolves builders in a value
 * @param value - Value to resolve
 * @param context - Optional build context
 * @returns Resolved value with all builders built
 */
function resolveValue<T, C extends BaseBuildContext>(
  value: unknown,
  context?: C
): unknown {
  if (isFluentBuilder<T, C>(value)) {
    return value.build(context);
  }

  if (Array.isArray(value)) {
    return value.map((item, index) => {
      const arrayContext = context ? createNestedContext(context, 'array', index) : undefined;
      return resolveValue(item, arrayContext);
    });
  }

  if (value && typeof value === 'object' && value.constructor === Object) {
    const resolved: Record<string, unknown> = {};
    for (const [key, val] of Object.entries(value)) {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      resolved[key] = resolveValue(val, nestedContext);
    }
    return resolved;
  }

  return value;
}

/**
 * Base class for all generated builders
 * Provides core functionality for the builder pattern
 */
abstract class FluentBuilderBase<T, C extends BaseBuildContext = BaseBuildContext> {
  /** Marks this as a fluent builder */
  readonly [FLUENT_BUILDER_SYMBOL] = true;
  /** Storage for property values */
  protected values: Partial<T> = {};
  /** Storage for nested builders - includes indexed keys for array elements */
  protected builders = new Map<string, FluentBuilder<unknown, C> | unknown>();
  /** Storage for mixed arrays (static values + builders) */
  protected mixedArrays = new Map<string, unknown[]>();
  /** Optional build context */
  protected context?: C;

  /**
   * Creates a new builder instance
   * @param initial - Optional initial values
   */
  constructor(initial?: Partial<T>) {
    if (initial) {
      this.values = { ...initial };
    }
  }

  /**
   * Sets a property value, handling both regular values and nested builders
   * @param key - The property key
   * @param value - The value or builder to set
   */
  protected set<K extends keyof T>(key: K, value: unknown): this {
    const keyStr = String(key);

    if (isFluentBuilder(value)) {
      this.builders.set(keyStr, value);
      // Clear from values if it was there
      delete this.values[key];
    } else if (Array.isArray(value)) {
      // Handle mixed arrays (builders + static values)
      const hasBuilders = value.some((item) => isFluentBuilder(item) ||
        (typeof item === 'object' && item !== null && this.containsBuilder(item)));

      if (hasBuilders) {
        // Store the array for mixed processing
        this.mixedArrays.set(keyStr, value);
        // Store individual builders with indexed keys
        value.forEach((item, index) => {
          if (isFluentBuilder(item)) {
            this.builders.set(\`\${keyStr}[\${index}]\`, item);
          } else if (typeof item === 'object' && item !== null && this.containsBuilder(item)) {
            // Store objects containing builders for recursive resolution
            this.builders.set(\`\${keyStr}[\${index}]\`, item);
          }
        });
        // Clear from values
        delete this.values[key];
      } else {
        // Pure static array
        this.values[key] = value as T[K];
        // Clear from mixed arrays if it was there
        this.mixedArrays.delete(keyStr);
      }
    } else if (typeof value === 'object' && value !== null && this.containsBuilder(value)) {
      // Object containing builders
      this.builders.set(keyStr, value);
      delete this.values[key];
    } else {
      // Static value
      this.values[key] = value as T[K];
      // Clear from builders if it was there
      this.builders.delete(keyStr);
      this.mixedArrays.delete(keyStr);
    }
    return this;
  }

  /**
   * Checks if an object contains any builders recursively
   */
  private containsBuilder(obj: unknown): boolean {
    if (isFluentBuilder(obj)) return true;
    if (Array.isArray(obj)) {
      return obj.some((item) => this.containsBuilder(item));
    }
    if (obj && typeof obj === 'object' && obj.constructor === Object) {
      return Object.values(obj).some((val) => this.containsBuilder(val));
    }
    return false;
  }

  /**
   * Builds the final object with defaults and nested builder resolution
   * @param defaults - Optional default values
   * @param context - Optional build context
   */
  protected buildWithDefaults(defaults?: Partial<T>, context?: C): T {
    const result: Record<string, unknown> = defaults ? { ...defaults } : {};

    // Apply explicitly set values
    Object.assign(result, this.values);

    // Process mixed arrays
    this.mixedArrays.forEach((array, key) => {
      const resolvedArray: unknown[] = [];
      array.forEach((item, index) => {
        const indexedKey = \`\${key}[\${index}]\`;
        const nestedContext = context ? createNestedContext(context, key, index) : undefined;

        // Check if this index has a builder stored
        if (this.builders.has(indexedKey)) {
          const builderOrObj = this.builders.get(indexedKey);
          resolvedArray[index] = resolveValue(builderOrObj, nestedContext);
        } else {
          // Static value
          resolvedArray[index] = item;
        }
      });
      result[key] = resolvedArray;
    });

    // Process regular builders (non-array)
    this.builders.forEach((value, key) => {
      // Skip indexed keys (they're handled in mixed arrays)
      if (key.includes('[')) return;
      // Skip keys that are in mixed arrays
      if (this.mixedArrays.has(key)) return;

      const nestedContext = context ? createNestedContext(context, key) : undefined;
      result[key] = resolveValue(value, nestedContext);
    });

    // Type assertion is safe here as we're building from typed values
    return result as T;
  }

  /**
   * Conditionally sets a property based on a predicate
   * @param predicate - Function to determine if the property should be set
   * @param property - The property key
   * @param value - The value or value generator
   */
  public if<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    value: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>)
  ): this {
    if (predicate(this)) {
      // Type guard: check if it's a function that's not a builder
      const resolvedValue = typeof value === 'function' && !isFluentBuilder(value)
        ? (value as () => T[K] | FluentBuilder<T[K], C>)()
        : value;
      this.set(property, resolvedValue);
    }
    return this;
  }

  /**
   * Conditionally sets a property choosing between two values
   * @param predicate - Function to determine which value to use
   * @param property - The property key
   * @param trueValue - Value to use if predicate is true
   * @param falseValue - Value to use if predicate is false
   */
  public ifElse<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    trueValue: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>),
    falseValue: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>)
  ): this {
    const valueToUse = predicate(this) ? trueValue : falseValue;
    // Type guard: check if it's a function that's not a builder
    const resolvedValue = typeof valueToUse === 'function' && !isFluentBuilder(valueToUse)
      ? (valueToUse as () => T[K] | FluentBuilder<T[K], C>)()
      : valueToUse;
    this.set(property, resolvedValue);
    return this;
  }

  /**
   * Checks if a property has been set
   * @param key - The property key to check
   */
  public has<K extends keyof T>(key: K): boolean {
    const keyStr = String(key);
    return key in this.values || this.builders.has(keyStr) || this.mixedArrays.has(keyStr);
  }

  /**
   * Get current value (useful for conditional logic)
   * @param key - The property key
   * @returns The current value or undefined
   */
  public peek<K extends keyof T>(key: K): T[K] | undefined {
    return this.values[key];
  }

  /**
   * Abstract build method to be implemented by generated builders
   * @param context - Optional build context
   */
  abstract build(context?: C): T;
}

/**
 * Creates an inspect method for better debugging experience
 * @param builderName - Name of the builder class
 * @param properties - Current builder properties
 * @returns Formatted string for inspection
 */
function createInspectMethod(builderName: string, properties: Record<string, unknown>): string {
  return \`\${builderName} { properties: \${JSON.stringify(properties, null, 2)} }\`;
}


import type { Result } from "./src/__tests__/fixtures/simple.ts";

export interface ResultBuilderMethods {

}

export class ResultBuilder extends FluentBuilderBase<Result> implements ResultBuilderMethods, FluentBuilder<Result, BaseBuildContext> {


  constructor(initial?: Partial<Result>) {
    super(initial);
  }



  /**
   * Builds the final Result object
   * @param context - Optional build context for nested builders
   */
  build(context?: BaseBuildContext): Result {
    return this.buildWithDefaults(undefined, context);
  }

  [Symbol.for("nodejs.util.inspect.custom")](): string {
    return createInspectMethod("ResultBuilder", this.values);
  }
}

export function result(initial?: Partial<Result>): ResultBuilder {
  return new ResultBuilder(initial);
}",
}
`;

exports[`FluentGen > generateBuilder > should generate builder for Address type 1`] = `
{
  "ok": true,
  "value": "
/**
 * Runtime utilities for fluent builders
 * Core functionality for builder pattern implementation
 */

/**
 * Unique symbol for identifying fluent builders
 * Used across module boundaries for proper type identification
 */
const FLUENT_BUILDER_SYMBOL = Symbol.for("fluent-builder");

/**
 * Base context interface for builder operations
 * Provides information about the builder's position in the object hierarchy
 */
interface BaseBuildContext {
  /** Parent builder identifier */
  readonly parentId?: string;
  /** Name of the parameter being built */
  readonly parameterName?: string;
  /** Index in array if building array elements */
  readonly index?: number;
  /** Additional context properties */
  readonly [key: string]: unknown;
}

/**
 * Core fluent builder interface
 * All generated builders implement this interface
 */
interface FluentBuilder<T, C extends BaseBuildContext = BaseBuildContext> {
  /** Identifies this as a fluent builder */
  readonly [FLUENT_BUILDER_SYMBOL]: true;
  /**
   * Builds the final object
   * @param context - Optional build context
   */
  build(context?: C): T;
}

/**
 * Type guard to check if a value is a fluent builder
 * Uses Symbol.for to ensure proper identification across module boundaries
 * @param value - Value to check
 * @returns True if value is a fluent builder
 */
function isFluentBuilder<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is FluentBuilder<T, C> {
  if (value === null || typeof value !== "object") {
    return false;
  }

  // Safely check for symbol property
  const hasSymbol = FLUENT_BUILDER_SYMBOL in value;
  if (!hasSymbol) {
    return false;
  }

  // Type narrowing: at this point we know it's an object with our symbol
  const obj = value as { [FLUENT_BUILDER_SYMBOL]: unknown; build?: unknown };

  return (
    obj[FLUENT_BUILDER_SYMBOL] === true &&
    typeof obj.build === "function"
  );
}

/**
 * Type guard to check if a value is a builder array
 * @param value - Value to check
 * @returns True if value is an array of builders
 */
function isBuilderArray<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is Array<FluentBuilder<T, C>> {
  return Array.isArray(value) && value.every(isFluentBuilder);
}

/**
 * Creates a new context for nested builders with proper inheritance
 * @param parentContext - Context from parent builder
 * @param parameterName - Name of the parameter being built
 * @param index - Optional array index
 * @returns New context with inherited properties
 */
function createNestedContext<C extends BaseBuildContext>(
  parentContext: C,
  parameterName: string,
  index?: number,
): C {
  return {
    ...parentContext,
    parameterName,
    index,
  } as C;
}

/**
 * Recursively resolves builders in a value
 * @param value - Value to resolve
 * @param context - Optional build context
 * @returns Resolved value with all builders built
 */
function resolveValue<T, C extends BaseBuildContext>(
  value: unknown,
  context?: C
): unknown {
  if (isFluentBuilder<T, C>(value)) {
    return value.build(context);
  }

  if (Array.isArray(value)) {
    return value.map((item, index) => {
      const arrayContext = context ? createNestedContext(context, 'array', index) : undefined;
      return resolveValue(item, arrayContext);
    });
  }

  if (value && typeof value === 'object' && value.constructor === Object) {
    const resolved: Record<string, unknown> = {};
    for (const [key, val] of Object.entries(value)) {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      resolved[key] = resolveValue(val, nestedContext);
    }
    return resolved;
  }

  return value;
}

/**
 * Base class for all generated builders
 * Provides core functionality for the builder pattern
 */
abstract class FluentBuilderBase<T, C extends BaseBuildContext = BaseBuildContext> {
  /** Marks this as a fluent builder */
  readonly [FLUENT_BUILDER_SYMBOL] = true;
  /** Storage for property values */
  protected values: Partial<T> = {};
  /** Storage for nested builders - includes indexed keys for array elements */
  protected builders = new Map<string, FluentBuilder<unknown, C> | unknown>();
  /** Storage for mixed arrays (static values + builders) */
  protected mixedArrays = new Map<string, unknown[]>();
  /** Optional build context */
  protected context?: C;

  /**
   * Creates a new builder instance
   * @param initial - Optional initial values
   */
  constructor(initial?: Partial<T>) {
    if (initial) {
      this.values = { ...initial };
    }
  }

  /**
   * Sets a property value, handling both regular values and nested builders
   * @param key - The property key
   * @param value - The value or builder to set
   */
  protected set<K extends keyof T>(key: K, value: unknown): this {
    const keyStr = String(key);

    if (isFluentBuilder(value)) {
      this.builders.set(keyStr, value);
      // Clear from values if it was there
      delete this.values[key];
    } else if (Array.isArray(value)) {
      // Handle mixed arrays (builders + static values)
      const hasBuilders = value.some((item) => isFluentBuilder(item) ||
        (typeof item === 'object' && item !== null && this.containsBuilder(item)));

      if (hasBuilders) {
        // Store the array for mixed processing
        this.mixedArrays.set(keyStr, value);
        // Store individual builders with indexed keys
        value.forEach((item, index) => {
          if (isFluentBuilder(item)) {
            this.builders.set(\`\${keyStr}[\${index}]\`, item);
          } else if (typeof item === 'object' && item !== null && this.containsBuilder(item)) {
            // Store objects containing builders for recursive resolution
            this.builders.set(\`\${keyStr}[\${index}]\`, item);
          }
        });
        // Clear from values
        delete this.values[key];
      } else {
        // Pure static array
        this.values[key] = value as T[K];
        // Clear from mixed arrays if it was there
        this.mixedArrays.delete(keyStr);
      }
    } else if (typeof value === 'object' && value !== null && this.containsBuilder(value)) {
      // Object containing builders
      this.builders.set(keyStr, value);
      delete this.values[key];
    } else {
      // Static value
      this.values[key] = value as T[K];
      // Clear from builders if it was there
      this.builders.delete(keyStr);
      this.mixedArrays.delete(keyStr);
    }
    return this;
  }

  /**
   * Checks if an object contains any builders recursively
   */
  private containsBuilder(obj: unknown): boolean {
    if (isFluentBuilder(obj)) return true;
    if (Array.isArray(obj)) {
      return obj.some((item) => this.containsBuilder(item));
    }
    if (obj && typeof obj === 'object' && obj.constructor === Object) {
      return Object.values(obj).some((val) => this.containsBuilder(val));
    }
    return false;
  }

  /**
   * Builds the final object with defaults and nested builder resolution
   * @param defaults - Optional default values
   * @param context - Optional build context
   */
  protected buildWithDefaults(defaults?: Partial<T>, context?: C): T {
    const result: Record<string, unknown> = defaults ? { ...defaults } : {};

    // Apply explicitly set values
    Object.assign(result, this.values);

    // Process mixed arrays
    this.mixedArrays.forEach((array, key) => {
      const resolvedArray: unknown[] = [];
      array.forEach((item, index) => {
        const indexedKey = \`\${key}[\${index}]\`;
        const nestedContext = context ? createNestedContext(context, key, index) : undefined;

        // Check if this index has a builder stored
        if (this.builders.has(indexedKey)) {
          const builderOrObj = this.builders.get(indexedKey);
          resolvedArray[index] = resolveValue(builderOrObj, nestedContext);
        } else {
          // Static value
          resolvedArray[index] = item;
        }
      });
      result[key] = resolvedArray;
    });

    // Process regular builders (non-array)
    this.builders.forEach((value, key) => {
      // Skip indexed keys (they're handled in mixed arrays)
      if (key.includes('[')) return;
      // Skip keys that are in mixed arrays
      if (this.mixedArrays.has(key)) return;

      const nestedContext = context ? createNestedContext(context, key) : undefined;
      result[key] = resolveValue(value, nestedContext);
    });

    // Type assertion is safe here as we're building from typed values
    return result as T;
  }

  /**
   * Conditionally sets a property based on a predicate
   * @param predicate - Function to determine if the property should be set
   * @param property - The property key
   * @param value - The value or value generator
   */
  public if<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    value: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>)
  ): this {
    if (predicate(this)) {
      // Type guard: check if it's a function that's not a builder
      const resolvedValue = typeof value === 'function' && !isFluentBuilder(value)
        ? (value as () => T[K] | FluentBuilder<T[K], C>)()
        : value;
      this.set(property, resolvedValue);
    }
    return this;
  }

  /**
   * Conditionally sets a property choosing between two values
   * @param predicate - Function to determine which value to use
   * @param property - The property key
   * @param trueValue - Value to use if predicate is true
   * @param falseValue - Value to use if predicate is false
   */
  public ifElse<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    trueValue: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>),
    falseValue: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>)
  ): this {
    const valueToUse = predicate(this) ? trueValue : falseValue;
    // Type guard: check if it's a function that's not a builder
    const resolvedValue = typeof valueToUse === 'function' && !isFluentBuilder(valueToUse)
      ? (valueToUse as () => T[K] | FluentBuilder<T[K], C>)()
      : valueToUse;
    this.set(property, resolvedValue);
    return this;
  }

  /**
   * Checks if a property has been set
   * @param key - The property key to check
   */
  public has<K extends keyof T>(key: K): boolean {
    const keyStr = String(key);
    return key in this.values || this.builders.has(keyStr) || this.mixedArrays.has(keyStr);
  }

  /**
   * Get current value (useful for conditional logic)
   * @param key - The property key
   * @returns The current value or undefined
   */
  public peek<K extends keyof T>(key: K): T[K] | undefined {
    return this.values[key];
  }

  /**
   * Abstract build method to be implemented by generated builders
   * @param context - Optional build context
   */
  abstract build(context?: C): T;
}

/**
 * Creates an inspect method for better debugging experience
 * @param builderName - Name of the builder class
 * @param properties - Current builder properties
 * @returns Formatted string for inspection
 */
function createInspectMethod(builderName: string, properties: Record<string, unknown>): string {
  return \`\${builderName} { properties: \${JSON.stringify(properties, null, 2)} }\`;
}


import type { Address } from "./src/__tests__/fixtures/simple.ts";

export interface AddressBuilderMethods {
  /** Street name */
  withStreet(value: string): AddressBuilder;
  /** City name */
  withCity(value: string): AddressBuilder;
  /** Country code */
  withCountry(value: string): AddressBuilder;
}

export class AddressBuilder extends FluentBuilderBase<Address> implements AddressBuilderMethods, FluentBuilder<Address, BaseBuildContext> {
  private static readonly defaults: Record<string, unknown> = { street: "", city: "", country: "" };

  constructor(initial?: Partial<Address>) {
    super(initial);
  }

  /** Street name */

  withStreet(value: string): AddressBuilder {
    return this.set("street", value);
  }

  /** City name */

  withCity(value: string): AddressBuilder {
    return this.set("city", value);
  }

  /** Country code */

  withCountry(value: string): AddressBuilder {
    return this.set("country", value);
  }

  /**
   * Builds the final Address object
   * @param context - Optional build context for nested builders
   */
  build(context?: BaseBuildContext): Address {
    return this.buildWithDefaults(AddressBuilder.defaults, context);
  }

  [Symbol.for("nodejs.util.inspect.custom")](): string {
    return createInspectMethod("AddressBuilder", this.values);
  }
}

/**
 * Creates a new Address builder
 * @param initial Optional initial values
 * @returns A fluent builder for Address
 */
export function address(initial?: Partial<Address>): AddressBuilder {
  return new AddressBuilder(initial);
}",
}
`;

exports[`FluentGen > generateBuilder > should generate builder for User type with nested Address 1`] = `
{
  "ok": true,
  "value": "
/**
 * Runtime utilities for fluent builders
 * Core functionality for builder pattern implementation
 */

/**
 * Unique symbol for identifying fluent builders
 * Used across module boundaries for proper type identification
 */
const FLUENT_BUILDER_SYMBOL = Symbol.for("fluent-builder");

/**
 * Base context interface for builder operations
 * Provides information about the builder's position in the object hierarchy
 */
interface BaseBuildContext {
  /** Parent builder identifier */
  readonly parentId?: string;
  /** Name of the parameter being built */
  readonly parameterName?: string;
  /** Index in array if building array elements */
  readonly index?: number;
  /** Additional context properties */
  readonly [key: string]: unknown;
}

/**
 * Core fluent builder interface
 * All generated builders implement this interface
 */
interface FluentBuilder<T, C extends BaseBuildContext = BaseBuildContext> {
  /** Identifies this as a fluent builder */
  readonly [FLUENT_BUILDER_SYMBOL]: true;
  /**
   * Builds the final object
   * @param context - Optional build context
   */
  build(context?: C): T;
}

/**
 * Type guard to check if a value is a fluent builder
 * Uses Symbol.for to ensure proper identification across module boundaries
 * @param value - Value to check
 * @returns True if value is a fluent builder
 */
function isFluentBuilder<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is FluentBuilder<T, C> {
  if (value === null || typeof value !== "object") {
    return false;
  }

  // Safely check for symbol property
  const hasSymbol = FLUENT_BUILDER_SYMBOL in value;
  if (!hasSymbol) {
    return false;
  }

  // Type narrowing: at this point we know it's an object with our symbol
  const obj = value as { [FLUENT_BUILDER_SYMBOL]: unknown; build?: unknown };

  return (
    obj[FLUENT_BUILDER_SYMBOL] === true &&
    typeof obj.build === "function"
  );
}

/**
 * Type guard to check if a value is a builder array
 * @param value - Value to check
 * @returns True if value is an array of builders
 */
function isBuilderArray<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is Array<FluentBuilder<T, C>> {
  return Array.isArray(value) && value.every(isFluentBuilder);
}

/**
 * Creates a new context for nested builders with proper inheritance
 * @param parentContext - Context from parent builder
 * @param parameterName - Name of the parameter being built
 * @param index - Optional array index
 * @returns New context with inherited properties
 */
function createNestedContext<C extends BaseBuildContext>(
  parentContext: C,
  parameterName: string,
  index?: number,
): C {
  return {
    ...parentContext,
    parameterName,
    index,
  } as C;
}

/**
 * Recursively resolves builders in a value
 * @param value - Value to resolve
 * @param context - Optional build context
 * @returns Resolved value with all builders built
 */
function resolveValue<T, C extends BaseBuildContext>(
  value: unknown,
  context?: C
): unknown {
  if (isFluentBuilder<T, C>(value)) {
    return value.build(context);
  }

  if (Array.isArray(value)) {
    return value.map((item, index) => {
      const arrayContext = context ? createNestedContext(context, 'array', index) : undefined;
      return resolveValue(item, arrayContext);
    });
  }

  if (value && typeof value === 'object' && value.constructor === Object) {
    const resolved: Record<string, unknown> = {};
    for (const [key, val] of Object.entries(value)) {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      resolved[key] = resolveValue(val, nestedContext);
    }
    return resolved;
  }

  return value;
}

/**
 * Base class for all generated builders
 * Provides core functionality for the builder pattern
 */
abstract class FluentBuilderBase<T, C extends BaseBuildContext = BaseBuildContext> {
  /** Marks this as a fluent builder */
  readonly [FLUENT_BUILDER_SYMBOL] = true;
  /** Storage for property values */
  protected values: Partial<T> = {};
  /** Storage for nested builders - includes indexed keys for array elements */
  protected builders = new Map<string, FluentBuilder<unknown, C> | unknown>();
  /** Storage for mixed arrays (static values + builders) */
  protected mixedArrays = new Map<string, unknown[]>();
  /** Optional build context */
  protected context?: C;

  /**
   * Creates a new builder instance
   * @param initial - Optional initial values
   */
  constructor(initial?: Partial<T>) {
    if (initial) {
      this.values = { ...initial };
    }
  }

  /**
   * Sets a property value, handling both regular values and nested builders
   * @param key - The property key
   * @param value - The value or builder to set
   */
  protected set<K extends keyof T>(key: K, value: unknown): this {
    const keyStr = String(key);

    if (isFluentBuilder(value)) {
      this.builders.set(keyStr, value);
      // Clear from values if it was there
      delete this.values[key];
    } else if (Array.isArray(value)) {
      // Handle mixed arrays (builders + static values)
      const hasBuilders = value.some((item) => isFluentBuilder(item) ||
        (typeof item === 'object' && item !== null && this.containsBuilder(item)));

      if (hasBuilders) {
        // Store the array for mixed processing
        this.mixedArrays.set(keyStr, value);
        // Store individual builders with indexed keys
        value.forEach((item, index) => {
          if (isFluentBuilder(item)) {
            this.builders.set(\`\${keyStr}[\${index}]\`, item);
          } else if (typeof item === 'object' && item !== null && this.containsBuilder(item)) {
            // Store objects containing builders for recursive resolution
            this.builders.set(\`\${keyStr}[\${index}]\`, item);
          }
        });
        // Clear from values
        delete this.values[key];
      } else {
        // Pure static array
        this.values[key] = value as T[K];
        // Clear from mixed arrays if it was there
        this.mixedArrays.delete(keyStr);
      }
    } else if (typeof value === 'object' && value !== null && this.containsBuilder(value)) {
      // Object containing builders
      this.builders.set(keyStr, value);
      delete this.values[key];
    } else {
      // Static value
      this.values[key] = value as T[K];
      // Clear from builders if it was there
      this.builders.delete(keyStr);
      this.mixedArrays.delete(keyStr);
    }
    return this;
  }

  /**
   * Checks if an object contains any builders recursively
   */
  private containsBuilder(obj: unknown): boolean {
    if (isFluentBuilder(obj)) return true;
    if (Array.isArray(obj)) {
      return obj.some((item) => this.containsBuilder(item));
    }
    if (obj && typeof obj === 'object' && obj.constructor === Object) {
      return Object.values(obj).some((val) => this.containsBuilder(val));
    }
    return false;
  }

  /**
   * Builds the final object with defaults and nested builder resolution
   * @param defaults - Optional default values
   * @param context - Optional build context
   */
  protected buildWithDefaults(defaults?: Partial<T>, context?: C): T {
    const result: Record<string, unknown> = defaults ? { ...defaults } : {};

    // Apply explicitly set values
    Object.assign(result, this.values);

    // Process mixed arrays
    this.mixedArrays.forEach((array, key) => {
      const resolvedArray: unknown[] = [];
      array.forEach((item, index) => {
        const indexedKey = \`\${key}[\${index}]\`;
        const nestedContext = context ? createNestedContext(context, key, index) : undefined;

        // Check if this index has a builder stored
        if (this.builders.has(indexedKey)) {
          const builderOrObj = this.builders.get(indexedKey);
          resolvedArray[index] = resolveValue(builderOrObj, nestedContext);
        } else {
          // Static value
          resolvedArray[index] = item;
        }
      });
      result[key] = resolvedArray;
    });

    // Process regular builders (non-array)
    this.builders.forEach((value, key) => {
      // Skip indexed keys (they're handled in mixed arrays)
      if (key.includes('[')) return;
      // Skip keys that are in mixed arrays
      if (this.mixedArrays.has(key)) return;

      const nestedContext = context ? createNestedContext(context, key) : undefined;
      result[key] = resolveValue(value, nestedContext);
    });

    // Type assertion is safe here as we're building from typed values
    return result as T;
  }

  /**
   * Conditionally sets a property based on a predicate
   * @param predicate - Function to determine if the property should be set
   * @param property - The property key
   * @param value - The value or value generator
   */
  public if<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    value: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>)
  ): this {
    if (predicate(this)) {
      // Type guard: check if it's a function that's not a builder
      const resolvedValue = typeof value === 'function' && !isFluentBuilder(value)
        ? (value as () => T[K] | FluentBuilder<T[K], C>)()
        : value;
      this.set(property, resolvedValue);
    }
    return this;
  }

  /**
   * Conditionally sets a property choosing between two values
   * @param predicate - Function to determine which value to use
   * @param property - The property key
   * @param trueValue - Value to use if predicate is true
   * @param falseValue - Value to use if predicate is false
   */
  public ifElse<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    trueValue: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>),
    falseValue: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>)
  ): this {
    const valueToUse = predicate(this) ? trueValue : falseValue;
    // Type guard: check if it's a function that's not a builder
    const resolvedValue = typeof valueToUse === 'function' && !isFluentBuilder(valueToUse)
      ? (valueToUse as () => T[K] | FluentBuilder<T[K], C>)()
      : valueToUse;
    this.set(property, resolvedValue);
    return this;
  }

  /**
   * Checks if a property has been set
   * @param key - The property key to check
   */
  public has<K extends keyof T>(key: K): boolean {
    const keyStr = String(key);
    return key in this.values || this.builders.has(keyStr) || this.mixedArrays.has(keyStr);
  }

  /**
   * Get current value (useful for conditional logic)
   * @param key - The property key
   * @returns The current value or undefined
   */
  public peek<K extends keyof T>(key: K): T[K] | undefined {
    return this.values[key];
  }

  /**
   * Abstract build method to be implemented by generated builders
   * @param context - Optional build context
   */
  abstract build(context?: C): T;
}

/**
 * Creates an inspect method for better debugging experience
 * @param builderName - Name of the builder class
 * @param properties - Current builder properties
 * @returns Formatted string for inspection
 */
function createInspectMethod(builderName: string, properties: Record<string, unknown>): string {
  return \`\${builderName} { properties: \${JSON.stringify(properties, null, 2)} }\`;
}


import type { User, Address } from "./src/__tests__/fixtures/simple.ts";

export interface UserBuilderMethods {
  /** Unique identifier */
  withId(value: string): UserBuilder;
  /** Full name */
  withName(value: string): UserBuilder;
  /** Age in years */
  withAge(value: number): UserBuilder;
  /** User address */
  withAddress(value: Address | FluentBuilder<Address, BaseBuildContext>): UserBuilder;
}

export class UserBuilder extends FluentBuilderBase<User> implements UserBuilderMethods, FluentBuilder<User, BaseBuildContext> {
  private static readonly defaults: Record<string, unknown> = { id: "", name: "", address: { street: "", city: "", country: "" } };

  constructor(initial?: Partial<User>) {
    super(initial);
  }

  /** Unique identifier */

  withId(value: string): UserBuilder {
    return this.set("id", value);
  }

  /** Full name */

  withName(value: string): UserBuilder {
    return this.set("name", value);
  }

  /** Age in years */

  withAge(value: number): UserBuilder {
    return this.set("age", value);
  }

  /** User address */

  withAddress(value: Address | FluentBuilder<Address, BaseBuildContext>): UserBuilder {
    return this.set("address", value);
  }

  /**
   * Builds the final User object
   * @param context - Optional build context for nested builders
   */
  build(context?: BaseBuildContext): User {
    return this.buildWithDefaults(UserBuilder.defaults, context);
  }

  [Symbol.for("nodejs.util.inspect.custom")](): string {
    return createInspectMethod("UserBuilder", this.values);
  }
}

/**
 * Creates a new User builder
 * @param initial Optional initial values
 * @returns A fluent builder for User
 */
export function user(initial?: Partial<User>): UserBuilder {
  return new UserBuilder(initial);
}",
}
`;

exports[`FluentGen > generateBuilder > should generate builder for generic ApiResponse type 1`] = `
{
  "ok": true,
  "value": "
/**
 * Runtime utilities for fluent builders
 * Core functionality for builder pattern implementation
 */

/**
 * Unique symbol for identifying fluent builders
 * Used across module boundaries for proper type identification
 */
const FLUENT_BUILDER_SYMBOL = Symbol.for("fluent-builder");

/**
 * Base context interface for builder operations
 * Provides information about the builder's position in the object hierarchy
 */
interface BaseBuildContext {
  /** Parent builder identifier */
  readonly parentId?: string;
  /** Name of the parameter being built */
  readonly parameterName?: string;
  /** Index in array if building array elements */
  readonly index?: number;
  /** Additional context properties */
  readonly [key: string]: unknown;
}

/**
 * Core fluent builder interface
 * All generated builders implement this interface
 */
interface FluentBuilder<T, C extends BaseBuildContext = BaseBuildContext> {
  /** Identifies this as a fluent builder */
  readonly [FLUENT_BUILDER_SYMBOL]: true;
  /**
   * Builds the final object
   * @param context - Optional build context
   */
  build(context?: C): T;
}

/**
 * Type guard to check if a value is a fluent builder
 * Uses Symbol.for to ensure proper identification across module boundaries
 * @param value - Value to check
 * @returns True if value is a fluent builder
 */
function isFluentBuilder<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is FluentBuilder<T, C> {
  if (value === null || typeof value !== "object") {
    return false;
  }

  // Safely check for symbol property
  const hasSymbol = FLUENT_BUILDER_SYMBOL in value;
  if (!hasSymbol) {
    return false;
  }

  // Type narrowing: at this point we know it's an object with our symbol
  const obj = value as { [FLUENT_BUILDER_SYMBOL]: unknown; build?: unknown };

  return (
    obj[FLUENT_BUILDER_SYMBOL] === true &&
    typeof obj.build === "function"
  );
}

/**
 * Type guard to check if a value is a builder array
 * @param value - Value to check
 * @returns True if value is an array of builders
 */
function isBuilderArray<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is Array<FluentBuilder<T, C>> {
  return Array.isArray(value) && value.every(isFluentBuilder);
}

/**
 * Creates a new context for nested builders with proper inheritance
 * @param parentContext - Context from parent builder
 * @param parameterName - Name of the parameter being built
 * @param index - Optional array index
 * @returns New context with inherited properties
 */
function createNestedContext<C extends BaseBuildContext>(
  parentContext: C,
  parameterName: string,
  index?: number,
): C {
  return {
    ...parentContext,
    parameterName,
    index,
  } as C;
}

/**
 * Recursively resolves builders in a value
 * @param value - Value to resolve
 * @param context - Optional build context
 * @returns Resolved value with all builders built
 */
function resolveValue<T, C extends BaseBuildContext>(
  value: unknown,
  context?: C
): unknown {
  if (isFluentBuilder<T, C>(value)) {
    return value.build(context);
  }

  if (Array.isArray(value)) {
    return value.map((item, index) => {
      const arrayContext = context ? createNestedContext(context, 'array', index) : undefined;
      return resolveValue(item, arrayContext);
    });
  }

  if (value && typeof value === 'object' && value.constructor === Object) {
    const resolved: Record<string, unknown> = {};
    for (const [key, val] of Object.entries(value)) {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      resolved[key] = resolveValue(val, nestedContext);
    }
    return resolved;
  }

  return value;
}

/**
 * Base class for all generated builders
 * Provides core functionality for the builder pattern
 */
abstract class FluentBuilderBase<T, C extends BaseBuildContext = BaseBuildContext> {
  /** Marks this as a fluent builder */
  readonly [FLUENT_BUILDER_SYMBOL] = true;
  /** Storage for property values */
  protected values: Partial<T> = {};
  /** Storage for nested builders - includes indexed keys for array elements */
  protected builders = new Map<string, FluentBuilder<unknown, C> | unknown>();
  /** Storage for mixed arrays (static values + builders) */
  protected mixedArrays = new Map<string, unknown[]>();
  /** Optional build context */
  protected context?: C;

  /**
   * Creates a new builder instance
   * @param initial - Optional initial values
   */
  constructor(initial?: Partial<T>) {
    if (initial) {
      this.values = { ...initial };
    }
  }

  /**
   * Sets a property value, handling both regular values and nested builders
   * @param key - The property key
   * @param value - The value or builder to set
   */
  protected set<K extends keyof T>(key: K, value: unknown): this {
    const keyStr = String(key);

    if (isFluentBuilder(value)) {
      this.builders.set(keyStr, value);
      // Clear from values if it was there
      delete this.values[key];
    } else if (Array.isArray(value)) {
      // Handle mixed arrays (builders + static values)
      const hasBuilders = value.some((item) => isFluentBuilder(item) ||
        (typeof item === 'object' && item !== null && this.containsBuilder(item)));

      if (hasBuilders) {
        // Store the array for mixed processing
        this.mixedArrays.set(keyStr, value);
        // Store individual builders with indexed keys
        value.forEach((item, index) => {
          if (isFluentBuilder(item)) {
            this.builders.set(\`\${keyStr}[\${index}]\`, item);
          } else if (typeof item === 'object' && item !== null && this.containsBuilder(item)) {
            // Store objects containing builders for recursive resolution
            this.builders.set(\`\${keyStr}[\${index}]\`, item);
          }
        });
        // Clear from values
        delete this.values[key];
      } else {
        // Pure static array
        this.values[key] = value as T[K];
        // Clear from mixed arrays if it was there
        this.mixedArrays.delete(keyStr);
      }
    } else if (typeof value === 'object' && value !== null && this.containsBuilder(value)) {
      // Object containing builders
      this.builders.set(keyStr, value);
      delete this.values[key];
    } else {
      // Static value
      this.values[key] = value as T[K];
      // Clear from builders if it was there
      this.builders.delete(keyStr);
      this.mixedArrays.delete(keyStr);
    }
    return this;
  }

  /**
   * Checks if an object contains any builders recursively
   */
  private containsBuilder(obj: unknown): boolean {
    if (isFluentBuilder(obj)) return true;
    if (Array.isArray(obj)) {
      return obj.some((item) => this.containsBuilder(item));
    }
    if (obj && typeof obj === 'object' && obj.constructor === Object) {
      return Object.values(obj).some((val) => this.containsBuilder(val));
    }
    return false;
  }

  /**
   * Builds the final object with defaults and nested builder resolution
   * @param defaults - Optional default values
   * @param context - Optional build context
   */
  protected buildWithDefaults(defaults?: Partial<T>, context?: C): T {
    const result: Record<string, unknown> = defaults ? { ...defaults } : {};

    // Apply explicitly set values
    Object.assign(result, this.values);

    // Process mixed arrays
    this.mixedArrays.forEach((array, key) => {
      const resolvedArray: unknown[] = [];
      array.forEach((item, index) => {
        const indexedKey = \`\${key}[\${index}]\`;
        const nestedContext = context ? createNestedContext(context, key, index) : undefined;

        // Check if this index has a builder stored
        if (this.builders.has(indexedKey)) {
          const builderOrObj = this.builders.get(indexedKey);
          resolvedArray[index] = resolveValue(builderOrObj, nestedContext);
        } else {
          // Static value
          resolvedArray[index] = item;
        }
      });
      result[key] = resolvedArray;
    });

    // Process regular builders (non-array)
    this.builders.forEach((value, key) => {
      // Skip indexed keys (they're handled in mixed arrays)
      if (key.includes('[')) return;
      // Skip keys that are in mixed arrays
      if (this.mixedArrays.has(key)) return;

      const nestedContext = context ? createNestedContext(context, key) : undefined;
      result[key] = resolveValue(value, nestedContext);
    });

    // Type assertion is safe here as we're building from typed values
    return result as T;
  }

  /**
   * Conditionally sets a property based on a predicate
   * @param predicate - Function to determine if the property should be set
   * @param property - The property key
   * @param value - The value or value generator
   */
  public if<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    value: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>)
  ): this {
    if (predicate(this)) {
      // Type guard: check if it's a function that's not a builder
      const resolvedValue = typeof value === 'function' && !isFluentBuilder(value)
        ? (value as () => T[K] | FluentBuilder<T[K], C>)()
        : value;
      this.set(property, resolvedValue);
    }
    return this;
  }

  /**
   * Conditionally sets a property choosing between two values
   * @param predicate - Function to determine which value to use
   * @param property - The property key
   * @param trueValue - Value to use if predicate is true
   * @param falseValue - Value to use if predicate is false
   */
  public ifElse<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    trueValue: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>),
    falseValue: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>)
  ): this {
    const valueToUse = predicate(this) ? trueValue : falseValue;
    // Type guard: check if it's a function that's not a builder
    const resolvedValue = typeof valueToUse === 'function' && !isFluentBuilder(valueToUse)
      ? (valueToUse as () => T[K] | FluentBuilder<T[K], C>)()
      : valueToUse;
    this.set(property, resolvedValue);
    return this;
  }

  /**
   * Checks if a property has been set
   * @param key - The property key to check
   */
  public has<K extends keyof T>(key: K): boolean {
    const keyStr = String(key);
    return key in this.values || this.builders.has(keyStr) || this.mixedArrays.has(keyStr);
  }

  /**
   * Get current value (useful for conditional logic)
   * @param key - The property key
   * @returns The current value or undefined
   */
  public peek<K extends keyof T>(key: K): T[K] | undefined {
    return this.values[key];
  }

  /**
   * Abstract build method to be implemented by generated builders
   * @param context - Optional build context
   */
  abstract build(context?: C): T;
}

/**
 * Creates an inspect method for better debugging experience
 * @param builderName - Name of the builder class
 * @param properties - Current builder properties
 * @returns Formatted string for inspection
 */
function createInspectMethod(builderName: string, properties: Record<string, unknown>): string {
  return \`\${builderName} { properties: \${JSON.stringify(properties, null, 2)} }\`;
}


import type { ApiResponse, User } from "./src/__tests__/fixtures/simple.ts";

export interface ApiResponseBuilderMethods<T = any, U extends User = User> {
  withData(value: T): ApiResponseBuilder<T, U>;
  withError(value: string): ApiResponseBuilder<T, U>;
  withUser(value: U): ApiResponseBuilder<T, U>;
  withTimestamp(value: number): ApiResponseBuilder<T, U>;
}

export class ApiResponseBuilder<T = any, U extends User = User> extends FluentBuilderBase<ApiResponse<T, U>> implements ApiResponseBuilderMethods<T, U>, FluentBuilder<ApiResponse<T, U>, BaseBuildContext> {
  private static readonly defaults: Record<string, unknown> = { timestamp: 0 };

  constructor(initial?: Partial<ApiResponse<T, U>>) {
    super(initial);
  }


  withData(value: T): ApiResponseBuilder<T, U> {
    return this.set("data", value);
  }


  withError(value: string): ApiResponseBuilder<T, U> {
    return this.set("error", value);
  }


  withUser(value: U): ApiResponseBuilder<T, U> {
    return this.set("user", value);
  }


  withTimestamp(value: number): ApiResponseBuilder<T, U> {
    return this.set("timestamp", value);
  }

  /**
   * Builds the final ApiResponse object
   * @param context - Optional build context for nested builders
   */
  build(context?: BaseBuildContext): ApiResponse<T, U> {
    return this.buildWithDefaults(ApiResponseBuilder.defaults, context);
  }

  [Symbol.for("nodejs.util.inspect.custom")](): string {
    return createInspectMethod("ApiResponseBuilder", this.values);
  }
}

/**
 * Creates a new ApiResponse builder
 * @param initial Optional initial values
 * @returns A fluent builder for ApiResponse
 */
export function apiResponse<T = any, U extends User = User>(initial?: Partial<ApiResponse<T, U>>): ApiResponseBuilder<T, U> {
  return new ApiResponseBuilder<T, U>(initial);
}",
}
`;

exports[`FluentGen > generateBuilder with JSDoc > should include JSDoc comments when addComments is true 1`] = `
{
  "ok": true,
  "value": "
/**
 * Runtime utilities for fluent builders
 * Core functionality for builder pattern implementation
 */

/**
 * Unique symbol for identifying fluent builders
 * Used across module boundaries for proper type identification
 */
const FLUENT_BUILDER_SYMBOL = Symbol.for("fluent-builder");

/**
 * Base context interface for builder operations
 * Provides information about the builder's position in the object hierarchy
 */
interface BaseBuildContext {
  /** Parent builder identifier */
  readonly parentId?: string;
  /** Name of the parameter being built */
  readonly parameterName?: string;
  /** Index in array if building array elements */
  readonly index?: number;
  /** Additional context properties */
  readonly [key: string]: unknown;
}

/**
 * Core fluent builder interface
 * All generated builders implement this interface
 */
interface FluentBuilder<T, C extends BaseBuildContext = BaseBuildContext> {
  /** Identifies this as a fluent builder */
  readonly [FLUENT_BUILDER_SYMBOL]: true;
  /**
   * Builds the final object
   * @param context - Optional build context
   */
  build(context?: C): T;
}

/**
 * Type guard to check if a value is a fluent builder
 * Uses Symbol.for to ensure proper identification across module boundaries
 * @param value - Value to check
 * @returns True if value is a fluent builder
 */
function isFluentBuilder<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is FluentBuilder<T, C> {
  if (value === null || typeof value !== "object") {
    return false;
  }

  // Safely check for symbol property
  const hasSymbol = FLUENT_BUILDER_SYMBOL in value;
  if (!hasSymbol) {
    return false;
  }

  // Type narrowing: at this point we know it's an object with our symbol
  const obj = value as { [FLUENT_BUILDER_SYMBOL]: unknown; build?: unknown };

  return (
    obj[FLUENT_BUILDER_SYMBOL] === true &&
    typeof obj.build === "function"
  );
}

/**
 * Type guard to check if a value is a builder array
 * @param value - Value to check
 * @returns True if value is an array of builders
 */
function isBuilderArray<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is Array<FluentBuilder<T, C>> {
  return Array.isArray(value) && value.every(isFluentBuilder);
}

/**
 * Creates a new context for nested builders with proper inheritance
 * @param parentContext - Context from parent builder
 * @param parameterName - Name of the parameter being built
 * @param index - Optional array index
 * @returns New context with inherited properties
 */
function createNestedContext<C extends BaseBuildContext>(
  parentContext: C,
  parameterName: string,
  index?: number,
): C {
  return {
    ...parentContext,
    parameterName,
    index,
  } as C;
}

/**
 * Recursively resolves builders in a value
 * @param value - Value to resolve
 * @param context - Optional build context
 * @returns Resolved value with all builders built
 */
function resolveValue<T, C extends BaseBuildContext>(
  value: unknown,
  context?: C
): unknown {
  if (isFluentBuilder<T, C>(value)) {
    return value.build(context);
  }

  if (Array.isArray(value)) {
    return value.map((item, index) => {
      const arrayContext = context ? createNestedContext(context, 'array', index) : undefined;
      return resolveValue(item, arrayContext);
    });
  }

  if (value && typeof value === 'object' && value.constructor === Object) {
    const resolved: Record<string, unknown> = {};
    for (const [key, val] of Object.entries(value)) {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      resolved[key] = resolveValue(val, nestedContext);
    }
    return resolved;
  }

  return value;
}

/**
 * Base class for all generated builders
 * Provides core functionality for the builder pattern
 */
abstract class FluentBuilderBase<T, C extends BaseBuildContext = BaseBuildContext> {
  /** Marks this as a fluent builder */
  readonly [FLUENT_BUILDER_SYMBOL] = true;
  /** Storage for property values */
  protected values: Partial<T> = {};
  /** Storage for nested builders - includes indexed keys for array elements */
  protected builders = new Map<string, FluentBuilder<unknown, C> | unknown>();
  /** Storage for mixed arrays (static values + builders) */
  protected mixedArrays = new Map<string, unknown[]>();
  /** Optional build context */
  protected context?: C;

  /**
   * Creates a new builder instance
   * @param initial - Optional initial values
   */
  constructor(initial?: Partial<T>) {
    if (initial) {
      this.values = { ...initial };
    }
  }

  /**
   * Sets a property value, handling both regular values and nested builders
   * @param key - The property key
   * @param value - The value or builder to set
   */
  protected set<K extends keyof T>(key: K, value: unknown): this {
    const keyStr = String(key);

    if (isFluentBuilder(value)) {
      this.builders.set(keyStr, value);
      // Clear from values if it was there
      delete this.values[key];
    } else if (Array.isArray(value)) {
      // Handle mixed arrays (builders + static values)
      const hasBuilders = value.some((item) => isFluentBuilder(item) ||
        (typeof item === 'object' && item !== null && this.containsBuilder(item)));

      if (hasBuilders) {
        // Store the array for mixed processing
        this.mixedArrays.set(keyStr, value);
        // Store individual builders with indexed keys
        value.forEach((item, index) => {
          if (isFluentBuilder(item)) {
            this.builders.set(\`\${keyStr}[\${index}]\`, item);
          } else if (typeof item === 'object' && item !== null && this.containsBuilder(item)) {
            // Store objects containing builders for recursive resolution
            this.builders.set(\`\${keyStr}[\${index}]\`, item);
          }
        });
        // Clear from values
        delete this.values[key];
      } else {
        // Pure static array
        this.values[key] = value as T[K];
        // Clear from mixed arrays if it was there
        this.mixedArrays.delete(keyStr);
      }
    } else if (typeof value === 'object' && value !== null && this.containsBuilder(value)) {
      // Object containing builders
      this.builders.set(keyStr, value);
      delete this.values[key];
    } else {
      // Static value
      this.values[key] = value as T[K];
      // Clear from builders if it was there
      this.builders.delete(keyStr);
      this.mixedArrays.delete(keyStr);
    }
    return this;
  }

  /**
   * Checks if an object contains any builders recursively
   */
  private containsBuilder(obj: unknown): boolean {
    if (isFluentBuilder(obj)) return true;
    if (Array.isArray(obj)) {
      return obj.some((item) => this.containsBuilder(item));
    }
    if (obj && typeof obj === 'object' && obj.constructor === Object) {
      return Object.values(obj).some((val) => this.containsBuilder(val));
    }
    return false;
  }

  /**
   * Builds the final object with defaults and nested builder resolution
   * @param defaults - Optional default values
   * @param context - Optional build context
   */
  protected buildWithDefaults(defaults?: Partial<T>, context?: C): T {
    const result: Record<string, unknown> = defaults ? { ...defaults } : {};

    // Apply explicitly set values
    Object.assign(result, this.values);

    // Process mixed arrays
    this.mixedArrays.forEach((array, key) => {
      const resolvedArray: unknown[] = [];
      array.forEach((item, index) => {
        const indexedKey = \`\${key}[\${index}]\`;
        const nestedContext = context ? createNestedContext(context, key, index) : undefined;

        // Check if this index has a builder stored
        if (this.builders.has(indexedKey)) {
          const builderOrObj = this.builders.get(indexedKey);
          resolvedArray[index] = resolveValue(builderOrObj, nestedContext);
        } else {
          // Static value
          resolvedArray[index] = item;
        }
      });
      result[key] = resolvedArray;
    });

    // Process regular builders (non-array)
    this.builders.forEach((value, key) => {
      // Skip indexed keys (they're handled in mixed arrays)
      if (key.includes('[')) return;
      // Skip keys that are in mixed arrays
      if (this.mixedArrays.has(key)) return;

      const nestedContext = context ? createNestedContext(context, key) : undefined;
      result[key] = resolveValue(value, nestedContext);
    });

    // Type assertion is safe here as we're building from typed values
    return result as T;
  }

  /**
   * Conditionally sets a property based on a predicate
   * @param predicate - Function to determine if the property should be set
   * @param property - The property key
   * @param value - The value or value generator
   */
  public if<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    value: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>)
  ): this {
    if (predicate(this)) {
      // Type guard: check if it's a function that's not a builder
      const resolvedValue = typeof value === 'function' && !isFluentBuilder(value)
        ? (value as () => T[K] | FluentBuilder<T[K], C>)()
        : value;
      this.set(property, resolvedValue);
    }
    return this;
  }

  /**
   * Conditionally sets a property choosing between two values
   * @param predicate - Function to determine which value to use
   * @param property - The property key
   * @param trueValue - Value to use if predicate is true
   * @param falseValue - Value to use if predicate is false
   */
  public ifElse<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    trueValue: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>),
    falseValue: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>)
  ): this {
    const valueToUse = predicate(this) ? trueValue : falseValue;
    // Type guard: check if it's a function that's not a builder
    const resolvedValue = typeof valueToUse === 'function' && !isFluentBuilder(valueToUse)
      ? (valueToUse as () => T[K] | FluentBuilder<T[K], C>)()
      : valueToUse;
    this.set(property, resolvedValue);
    return this;
  }

  /**
   * Checks if a property has been set
   * @param key - The property key to check
   */
  public has<K extends keyof T>(key: K): boolean {
    const keyStr = String(key);
    return key in this.values || this.builders.has(keyStr) || this.mixedArrays.has(keyStr);
  }

  /**
   * Get current value (useful for conditional logic)
   * @param key - The property key
   * @returns The current value or undefined
   */
  public peek<K extends keyof T>(key: K): T[K] | undefined {
    return this.values[key];
  }

  /**
   * Abstract build method to be implemented by generated builders
   * @param context - Optional build context
   */
  abstract build(context?: C): T;
}

/**
 * Creates an inspect method for better debugging experience
 * @param builderName - Name of the builder class
 * @param properties - Current builder properties
 * @returns Formatted string for inspection
 */
function createInspectMethod(builderName: string, properties: Record<string, unknown>): string {
  return \`\${builderName} { properties: \${JSON.stringify(properties, null, 2)} }\`;
}


import type { Address } from "./src/__tests__/fixtures/simple.ts";

export interface AddressBuilderMethods {
  /** Street name */
  withStreet(value: string): AddressBuilder;
  /** City name */
  withCity(value: string): AddressBuilder;
  /** Country code */
  withCountry(value: string): AddressBuilder;
}

export class AddressBuilder extends FluentBuilderBase<Address> implements AddressBuilderMethods, FluentBuilder<Address, BaseBuildContext> {
  private static readonly defaults: Record<string, unknown> = { street: "", city: "", country: "" };

  constructor(initial?: Partial<Address>) {
    super(initial);
  }

  /** Street name */

  withStreet(value: string): AddressBuilder {
    return this.set("street", value);
  }

  /** City name */

  withCity(value: string): AddressBuilder {
    return this.set("city", value);
  }

  /** Country code */

  withCountry(value: string): AddressBuilder {
    return this.set("country", value);
  }

  /**
   * Builds the final Address object
   * @param context - Optional build context for nested builders
   */
  build(context?: BaseBuildContext): Address {
    return this.buildWithDefaults(AddressBuilder.defaults, context);
  }

  [Symbol.for("nodejs.util.inspect.custom")](): string {
    return createInspectMethod("AddressBuilder", this.values);
  }
}

/**
 * Creates a new Address builder
 * @param initial Optional initial values
 * @returns A fluent builder for Address
 */
export function address(initial?: Partial<Address>): AddressBuilder {
  return new AddressBuilder(initial);
}",
}
`;

exports[`FluentGen > generateBuilder with JSDoc > should not include JSDoc comments when addComments is false 1`] = `
{
  "ok": true,
  "value": "
/**
 * Runtime utilities for fluent builders
 * Core functionality for builder pattern implementation
 */

/**
 * Unique symbol for identifying fluent builders
 * Used across module boundaries for proper type identification
 */
const FLUENT_BUILDER_SYMBOL = Symbol.for("fluent-builder");

/**
 * Base context interface for builder operations
 * Provides information about the builder's position in the object hierarchy
 */
interface BaseBuildContext {
  /** Parent builder identifier */
  readonly parentId?: string;
  /** Name of the parameter being built */
  readonly parameterName?: string;
  /** Index in array if building array elements */
  readonly index?: number;
  /** Additional context properties */
  readonly [key: string]: unknown;
}

/**
 * Core fluent builder interface
 * All generated builders implement this interface
 */
interface FluentBuilder<T, C extends BaseBuildContext = BaseBuildContext> {
  /** Identifies this as a fluent builder */
  readonly [FLUENT_BUILDER_SYMBOL]: true;
  /**
   * Builds the final object
   * @param context - Optional build context
   */
  build(context?: C): T;
}

/**
 * Type guard to check if a value is a fluent builder
 * Uses Symbol.for to ensure proper identification across module boundaries
 * @param value - Value to check
 * @returns True if value is a fluent builder
 */
function isFluentBuilder<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is FluentBuilder<T, C> {
  if (value === null || typeof value !== "object") {
    return false;
  }

  // Safely check for symbol property
  const hasSymbol = FLUENT_BUILDER_SYMBOL in value;
  if (!hasSymbol) {
    return false;
  }

  // Type narrowing: at this point we know it's an object with our symbol
  const obj = value as { [FLUENT_BUILDER_SYMBOL]: unknown; build?: unknown };

  return (
    obj[FLUENT_BUILDER_SYMBOL] === true &&
    typeof obj.build === "function"
  );
}

/**
 * Type guard to check if a value is a builder array
 * @param value - Value to check
 * @returns True if value is an array of builders
 */
function isBuilderArray<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is Array<FluentBuilder<T, C>> {
  return Array.isArray(value) && value.every(isFluentBuilder);
}

/**
 * Creates a new context for nested builders with proper inheritance
 * @param parentContext - Context from parent builder
 * @param parameterName - Name of the parameter being built
 * @param index - Optional array index
 * @returns New context with inherited properties
 */
function createNestedContext<C extends BaseBuildContext>(
  parentContext: C,
  parameterName: string,
  index?: number,
): C {
  return {
    ...parentContext,
    parameterName,
    index,
  } as C;
}

/**
 * Recursively resolves builders in a value
 * @param value - Value to resolve
 * @param context - Optional build context
 * @returns Resolved value with all builders built
 */
function resolveValue<T, C extends BaseBuildContext>(
  value: unknown,
  context?: C
): unknown {
  if (isFluentBuilder<T, C>(value)) {
    return value.build(context);
  }

  if (Array.isArray(value)) {
    return value.map((item, index) => {
      const arrayContext = context ? createNestedContext(context, 'array', index) : undefined;
      return resolveValue(item, arrayContext);
    });
  }

  if (value && typeof value === 'object' && value.constructor === Object) {
    const resolved: Record<string, unknown> = {};
    for (const [key, val] of Object.entries(value)) {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      resolved[key] = resolveValue(val, nestedContext);
    }
    return resolved;
  }

  return value;
}

/**
 * Base class for all generated builders
 * Provides core functionality for the builder pattern
 */
abstract class FluentBuilderBase<T, C extends BaseBuildContext = BaseBuildContext> {
  /** Marks this as a fluent builder */
  readonly [FLUENT_BUILDER_SYMBOL] = true;
  /** Storage for property values */
  protected values: Partial<T> = {};
  /** Storage for nested builders - includes indexed keys for array elements */
  protected builders = new Map<string, FluentBuilder<unknown, C> | unknown>();
  /** Storage for mixed arrays (static values + builders) */
  protected mixedArrays = new Map<string, unknown[]>();
  /** Optional build context */
  protected context?: C;

  /**
   * Creates a new builder instance
   * @param initial - Optional initial values
   */
  constructor(initial?: Partial<T>) {
    if (initial) {
      this.values = { ...initial };
    }
  }

  /**
   * Sets a property value, handling both regular values and nested builders
   * @param key - The property key
   * @param value - The value or builder to set
   */
  protected set<K extends keyof T>(key: K, value: unknown): this {
    const keyStr = String(key);

    if (isFluentBuilder(value)) {
      this.builders.set(keyStr, value);
      // Clear from values if it was there
      delete this.values[key];
    } else if (Array.isArray(value)) {
      // Handle mixed arrays (builders + static values)
      const hasBuilders = value.some((item) => isFluentBuilder(item) ||
        (typeof item === 'object' && item !== null && this.containsBuilder(item)));

      if (hasBuilders) {
        // Store the array for mixed processing
        this.mixedArrays.set(keyStr, value);
        // Store individual builders with indexed keys
        value.forEach((item, index) => {
          if (isFluentBuilder(item)) {
            this.builders.set(\`\${keyStr}[\${index}]\`, item);
          } else if (typeof item === 'object' && item !== null && this.containsBuilder(item)) {
            // Store objects containing builders for recursive resolution
            this.builders.set(\`\${keyStr}[\${index}]\`, item);
          }
        });
        // Clear from values
        delete this.values[key];
      } else {
        // Pure static array
        this.values[key] = value as T[K];
        // Clear from mixed arrays if it was there
        this.mixedArrays.delete(keyStr);
      }
    } else if (typeof value === 'object' && value !== null && this.containsBuilder(value)) {
      // Object containing builders
      this.builders.set(keyStr, value);
      delete this.values[key];
    } else {
      // Static value
      this.values[key] = value as T[K];
      // Clear from builders if it was there
      this.builders.delete(keyStr);
      this.mixedArrays.delete(keyStr);
    }
    return this;
  }

  /**
   * Checks if an object contains any builders recursively
   */
  private containsBuilder(obj: unknown): boolean {
    if (isFluentBuilder(obj)) return true;
    if (Array.isArray(obj)) {
      return obj.some((item) => this.containsBuilder(item));
    }
    if (obj && typeof obj === 'object' && obj.constructor === Object) {
      return Object.values(obj).some((val) => this.containsBuilder(val));
    }
    return false;
  }

  /**
   * Builds the final object with defaults and nested builder resolution
   * @param defaults - Optional default values
   * @param context - Optional build context
   */
  protected buildWithDefaults(defaults?: Partial<T>, context?: C): T {
    const result: Record<string, unknown> = defaults ? { ...defaults } : {};

    // Apply explicitly set values
    Object.assign(result, this.values);

    // Process mixed arrays
    this.mixedArrays.forEach((array, key) => {
      const resolvedArray: unknown[] = [];
      array.forEach((item, index) => {
        const indexedKey = \`\${key}[\${index}]\`;
        const nestedContext = context ? createNestedContext(context, key, index) : undefined;

        // Check if this index has a builder stored
        if (this.builders.has(indexedKey)) {
          const builderOrObj = this.builders.get(indexedKey);
          resolvedArray[index] = resolveValue(builderOrObj, nestedContext);
        } else {
          // Static value
          resolvedArray[index] = item;
        }
      });
      result[key] = resolvedArray;
    });

    // Process regular builders (non-array)
    this.builders.forEach((value, key) => {
      // Skip indexed keys (they're handled in mixed arrays)
      if (key.includes('[')) return;
      // Skip keys that are in mixed arrays
      if (this.mixedArrays.has(key)) return;

      const nestedContext = context ? createNestedContext(context, key) : undefined;
      result[key] = resolveValue(value, nestedContext);
    });

    // Type assertion is safe here as we're building from typed values
    return result as T;
  }

  /**
   * Conditionally sets a property based on a predicate
   * @param predicate - Function to determine if the property should be set
   * @param property - The property key
   * @param value - The value or value generator
   */
  public if<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    value: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>)
  ): this {
    if (predicate(this)) {
      // Type guard: check if it's a function that's not a builder
      const resolvedValue = typeof value === 'function' && !isFluentBuilder(value)
        ? (value as () => T[K] | FluentBuilder<T[K], C>)()
        : value;
      this.set(property, resolvedValue);
    }
    return this;
  }

  /**
   * Conditionally sets a property choosing between two values
   * @param predicate - Function to determine which value to use
   * @param property - The property key
   * @param trueValue - Value to use if predicate is true
   * @param falseValue - Value to use if predicate is false
   */
  public ifElse<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    trueValue: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>),
    falseValue: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>)
  ): this {
    const valueToUse = predicate(this) ? trueValue : falseValue;
    // Type guard: check if it's a function that's not a builder
    const resolvedValue = typeof valueToUse === 'function' && !isFluentBuilder(valueToUse)
      ? (valueToUse as () => T[K] | FluentBuilder<T[K], C>)()
      : valueToUse;
    this.set(property, resolvedValue);
    return this;
  }

  /**
   * Checks if a property has been set
   * @param key - The property key to check
   */
  public has<K extends keyof T>(key: K): boolean {
    const keyStr = String(key);
    return key in this.values || this.builders.has(keyStr) || this.mixedArrays.has(keyStr);
  }

  /**
   * Get current value (useful for conditional logic)
   * @param key - The property key
   * @returns The current value or undefined
   */
  public peek<K extends keyof T>(key: K): T[K] | undefined {
    return this.values[key];
  }

  /**
   * Abstract build method to be implemented by generated builders
   * @param context - Optional build context
   */
  abstract build(context?: C): T;
}

/**
 * Creates an inspect method for better debugging experience
 * @param builderName - Name of the builder class
 * @param properties - Current builder properties
 * @returns Formatted string for inspection
 */
function createInspectMethod(builderName: string, properties: Record<string, unknown>): string {
  return \`\${builderName} { properties: \${JSON.stringify(properties, null, 2)} }\`;
}


import type { Address } from "./src/__tests__/fixtures/simple.ts";

export interface AddressBuilderMethods {
  withStreet(value: string): AddressBuilder;
  withCity(value: string): AddressBuilder;
  withCountry(value: string): AddressBuilder;
}

export class AddressBuilder extends FluentBuilderBase<Address> implements AddressBuilderMethods, FluentBuilder<Address, BaseBuildContext> {
  private static readonly defaults: Record<string, unknown> = { street: "", city: "", country: "" };

  constructor(initial?: Partial<Address>) {
    super(initial);
  }


  withStreet(value: string): AddressBuilder {
    return this.set("street", value);
  }


  withCity(value: string): AddressBuilder {
    return this.set("city", value);
  }


  withCountry(value: string): AddressBuilder {
    return this.set("country", value);
  }

  /**
   * Builds the final Address object
   * @param context - Optional build context for nested builders
   */
  build(context?: BaseBuildContext): Address {
    return this.buildWithDefaults(AddressBuilder.defaults, context);
  }

  [Symbol.for("nodejs.util.inspect.custom")](): string {
    return createInspectMethod("AddressBuilder", this.values);
  }
}

export function address(initial?: Partial<Address>): AddressBuilder {
  return new AddressBuilder(initial);
}",
}
`;

exports[`FluentGen > generateMultiple > should generate builders for multiple types 1`] = `
{
  "ok": true,
  "value": Map {
    "common.ts" => "/**
 * Common utilities for fluent builders
 */

/**
 * Runtime utilities for fluent builders
 * Core functionality for builder pattern implementation
 */

/**
 * Unique symbol for identifying fluent builders
 * Used across module boundaries for proper type identification
 */
export const FLUENT_BUILDER_SYMBOL = Symbol.for("fluent-builder");

/**
 * Base context interface for builder operations
 * Provides information about the builder's position in the object hierarchy
 */
export interface BaseBuildContext {
  /** Parent builder identifier */
  readonly parentId?: string;
  /** Name of the parameter being built */
  readonly parameterName?: string;
  /** Index in array if building array elements */
  readonly index?: number;
  /** Additional context properties */
  readonly [key: string]: unknown;
}

/**
 * Core fluent builder interface
 * All generated builders implement this interface
 */
export interface FluentBuilder<T, C extends BaseBuildContext = BaseBuildContext> {
  /** Identifies this as a fluent builder */
  readonly [FLUENT_BUILDER_SYMBOL]: true;
  /**
   * Builds the final object
   * @param context - Optional build context
   */
  build(context?: C): T;
}

/**
 * Type guard to check if a value is a fluent builder
 * Uses Symbol.for to ensure proper identification across module boundaries
 * @param value - Value to check
 * @returns True if value is a fluent builder
 */
export function isFluentBuilder<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is FluentBuilder<T, C> {
  if (value === null || typeof value !== "object") {
    return false;
  }

  // Safely check for symbol property
  const hasSymbol = FLUENT_BUILDER_SYMBOL in value;
  if (!hasSymbol) {
    return false;
  }

  // Type narrowing: at this point we know it's an object with our symbol
  const obj = value as { [FLUENT_BUILDER_SYMBOL]: unknown; build?: unknown };

  return (
    obj[FLUENT_BUILDER_SYMBOL] === true &&
    typeof obj.build === "function"
  );
}

/**
 * Type guard to check if a value is a builder array
 * @param value - Value to check
 * @returns True if value is an array of builders
 */
export function isBuilderArray<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is Array<FluentBuilder<T, C>> {
  return Array.isArray(value) && value.every(isFluentBuilder);
}

/**
 * Creates a new context for nested builders with proper inheritance
 * @param parentContext - Context from parent builder
 * @param parameterName - Name of the parameter being built
 * @param index - Optional array index
 * @returns New context with inherited properties
 */
export function createNestedContext<C extends BaseBuildContext>(
  parentContext: C,
  parameterName: string,
  index?: number,
): C {
  return {
    ...parentContext,
    parameterName,
    index,
  } as C;
}

/**
 * Recursively resolves builders in a value
 * @param value - Value to resolve
 * @param context - Optional build context
 * @returns Resolved value with all builders built
 */
export function resolveValue<T, C extends BaseBuildContext>(
  value: unknown,
  context?: C
): unknown {
  if (isFluentBuilder<T, C>(value)) {
    return value.build(context);
  }

  if (Array.isArray(value)) {
    return value.map((item, index) => {
      const arrayContext = context ? createNestedContext(context, 'array', index) : undefined;
      return resolveValue(item, arrayContext);
    });
  }

  if (value && typeof value === 'object' && value.constructor === Object) {
    const resolved: Record<string, unknown> = {};
    for (const [key, val] of Object.entries(value)) {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      resolved[key] = resolveValue(val, nestedContext);
    }
    return resolved;
  }

  return value;
}

/**
 * Base class for all generated builders
 * Provides core functionality for the builder pattern
 */
export abstract class FluentBuilderBase<T, C extends BaseBuildContext = BaseBuildContext> {
  /** Marks this as a fluent builder */
  readonly [FLUENT_BUILDER_SYMBOL] = true;
  /** Storage for property values */
  protected values: Partial<T> = {};
  /** Storage for nested builders - includes indexed keys for array elements */
  protected builders = new Map<string, FluentBuilder<unknown, C> | unknown>();
  /** Storage for mixed arrays (static values + builders) */
  protected mixedArrays = new Map<string, unknown[]>();
  /** Optional build context */
  protected context?: C;

  /**
   * Creates a new builder instance
   * @param initial - Optional initial values
   */
  constructor(initial?: Partial<T>) {
    if (initial) {
      this.values = { ...initial };
    }
  }

  /**
   * Sets a property value, handling both regular values and nested builders
   * @param key - The property key
   * @param value - The value or builder to set
   */
  protected set<K extends keyof T>(key: K, value: unknown): this {
    const keyStr = String(key);

    if (isFluentBuilder(value)) {
      this.builders.set(keyStr, value);
      // Clear from values if it was there
      delete this.values[key];
    } else if (Array.isArray(value)) {
      // Handle mixed arrays (builders + static values)
      const hasBuilders = value.some((item) => isFluentBuilder(item) ||
        (typeof item === 'object' && item !== null && this.containsBuilder(item)));

      if (hasBuilders) {
        // Store the array for mixed processing
        this.mixedArrays.set(keyStr, value);
        // Store individual builders with indexed keys
        value.forEach((item, index) => {
          if (isFluentBuilder(item)) {
            this.builders.set(\`\${keyStr}[\${index}]\`, item);
          } else if (typeof item === 'object' && item !== null && this.containsBuilder(item)) {
            // Store objects containing builders for recursive resolution
            this.builders.set(\`\${keyStr}[\${index}]\`, item);
          }
        });
        // Clear from values
        delete this.values[key];
      } else {
        // Pure static array
        this.values[key] = value as T[K];
        // Clear from mixed arrays if it was there
        this.mixedArrays.delete(keyStr);
      }
    } else if (typeof value === 'object' && value !== null && this.containsBuilder(value)) {
      // Object containing builders
      this.builders.set(keyStr, value);
      delete this.values[key];
    } else {
      // Static value
      this.values[key] = value as T[K];
      // Clear from builders if it was there
      this.builders.delete(keyStr);
      this.mixedArrays.delete(keyStr);
    }
    return this;
  }

  /**
   * Checks if an object contains any builders recursively
   */
  private containsBuilder(obj: unknown): boolean {
    if (isFluentBuilder(obj)) return true;
    if (Array.isArray(obj)) {
      return obj.some((item) => this.containsBuilder(item));
    }
    if (obj && typeof obj === 'object' && obj.constructor === Object) {
      return Object.values(obj).some((val) => this.containsBuilder(val));
    }
    return false;
  }

  /**
   * Builds the final object with defaults and nested builder resolution
   * @param defaults - Optional default values
   * @param context - Optional build context
   */
  protected buildWithDefaults(defaults?: Partial<T>, context?: C): T {
    const result: Record<string, unknown> = defaults ? { ...defaults } : {};

    // Apply explicitly set values
    Object.assign(result, this.values);

    // Process mixed arrays
    this.mixedArrays.forEach((array, key) => {
      const resolvedArray: unknown[] = [];
      array.forEach((item, index) => {
        const indexedKey = \`\${key}[\${index}]\`;
        const nestedContext = context ? createNestedContext(context, key, index) : undefined;

        // Check if this index has a builder stored
        if (this.builders.has(indexedKey)) {
          const builderOrObj = this.builders.get(indexedKey);
          resolvedArray[index] = resolveValue(builderOrObj, nestedContext);
        } else {
          // Static value
          resolvedArray[index] = item;
        }
      });
      result[key] = resolvedArray;
    });

    // Process regular builders (non-array)
    this.builders.forEach((value, key) => {
      // Skip indexed keys (they're handled in mixed arrays)
      if (key.includes('[')) return;
      // Skip keys that are in mixed arrays
      if (this.mixedArrays.has(key)) return;

      const nestedContext = context ? createNestedContext(context, key) : undefined;
      result[key] = resolveValue(value, nestedContext);
    });

    // Type assertion is safe here as we're building from typed values
    return result as T;
  }

  /**
   * Conditionally sets a property based on a predicate
   * @param predicate - Function to determine if the property should be set
   * @param property - The property key
   * @param value - The value or value generator
   */
  public if<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    value: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>)
  ): this {
    if (predicate(this)) {
      // Type guard: check if it's a function that's not a builder
      const resolvedValue = typeof value === 'function' && !isFluentBuilder(value)
        ? (value as () => T[K] | FluentBuilder<T[K], C>)()
        : value;
      this.set(property, resolvedValue);
    }
    return this;
  }

  /**
   * Conditionally sets a property choosing between two values
   * @param predicate - Function to determine which value to use
   * @param property - The property key
   * @param trueValue - Value to use if predicate is true
   * @param falseValue - Value to use if predicate is false
   */
  public ifElse<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    trueValue: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>),
    falseValue: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>)
  ): this {
    const valueToUse = predicate(this) ? trueValue : falseValue;
    // Type guard: check if it's a function that's not a builder
    const resolvedValue = typeof valueToUse === 'function' && !isFluentBuilder(valueToUse)
      ? (valueToUse as () => T[K] | FluentBuilder<T[K], C>)()
      : valueToUse;
    this.set(property, resolvedValue);
    return this;
  }

  /**
   * Checks if a property has been set
   * @param key - The property key to check
   */
  public has<K extends keyof T>(key: K): boolean {
    const keyStr = String(key);
    return key in this.values || this.builders.has(keyStr) || this.mixedArrays.has(keyStr);
  }

  /**
   * Get current value (useful for conditional logic)
   * @param key - The property key
   * @returns The current value or undefined
   */
  public peek<K extends keyof T>(key: K): T[K] | undefined {
    return this.values[key];
  }

  /**
   * Abstract build method to be implemented by generated builders
   * @param context - Optional build context
   */
  abstract build(context?: C): T;
}

/**
 * Creates an inspect method for better debugging experience
 * @param builderName - Name of the builder class
 * @param properties - Current builder properties
 * @returns Formatted string for inspection
 */
export function createInspectMethod(builderName: string, properties: Record<string, unknown>): string {
  return \`\${builderName} { properties: \${JSON.stringify(properties, null, 2)} }\`;
}",
    "Address.ts" => "import {
  FluentBuilder,
  FluentBuilderBase,
  BaseBuildContext,
  FLUENT_BUILDER_SYMBOL,
  createInspectMethod
} from "./common.js";
import type { Address } from "./src/__tests__/fixtures/simple.ts";

export interface AddressBuilderMethods {
  /** Street name */
  withStreet(value: string): AddressBuilder;
  /** City name */
  withCity(value: string): AddressBuilder;
  /** Country code */
  withCountry(value: string): AddressBuilder;
}

export class AddressBuilder extends FluentBuilderBase<Address> implements AddressBuilderMethods, FluentBuilder<Address, BaseBuildContext> {
  private static readonly defaults: Record<string, unknown> = { street: "", city: "", country: "" };

  constructor(initial?: Partial<Address>) {
    super(initial);
  }

  /** Street name */

  withStreet(value: string): AddressBuilder {
    return this.set("street", value);
  }

  /** City name */

  withCity(value: string): AddressBuilder {
    return this.set("city", value);
  }

  /** Country code */

  withCountry(value: string): AddressBuilder {
    return this.set("country", value);
  }

  /**
   * Builds the final Address object
   * @param context - Optional build context for nested builders
   */
  build(context?: BaseBuildContext): Address {
    return this.buildWithDefaults(AddressBuilder.defaults, context);
  }

  [Symbol.for("nodejs.util.inspect.custom")](): string {
    return createInspectMethod("AddressBuilder", this.values);
  }
}

/**
 * Creates a new Address builder
 * @param initial Optional initial values
 * @returns A fluent builder for Address
 */
export function address(initial?: Partial<Address>): AddressBuilder {
  return new AddressBuilder(initial);
}",
    "Point.ts" => "import {
  FluentBuilder,
  FluentBuilderBase,
  BaseBuildContext,
  FLUENT_BUILDER_SYMBOL,
  createInspectMethod
} from "./common.js";
import type { Point } from "./src/__tests__/fixtures/simple.ts";

export interface PointBuilderMethods {
  withX(value: number): PointBuilder;
  withY(value: number): PointBuilder;
  withZ(value: number): PointBuilder;
}

export class PointBuilder extends FluentBuilderBase<Point> implements PointBuilderMethods, FluentBuilder<Point, BaseBuildContext> {
  private static readonly defaults: Record<string, unknown> = { x: 0, y: 0 };

  constructor(initial?: Partial<Point>) {
    super(initial);
  }


  withX(value: number): PointBuilder {
    return this.set("x", value);
  }


  withY(value: number): PointBuilder {
    return this.set("y", value);
  }


  withZ(value: number): PointBuilder {
    return this.set("z", value);
  }

  /**
   * Builds the final Point object
   * @param context - Optional build context for nested builders
   */
  build(context?: BaseBuildContext): Point {
    return this.buildWithDefaults(PointBuilder.defaults, context);
  }

  [Symbol.for("nodejs.util.inspect.custom")](): string {
    return createInspectMethod("PointBuilder", this.values);
  }
}

/**
 * Creates a new Point builder
 * @param initial Optional initial values
 * @returns A fluent builder for Point
 */
export function point(initial?: Partial<Point>): PointBuilder {
  return new PointBuilder(initial);
}",
  },
}
`;

exports[`FluentGen > generateMultiple > should handle empty type list 1`] = `
{
  "ok": true,
  "value": Map {
    "common.ts" => "/**
 * Common utilities for fluent builders
 */

/**
 * Runtime utilities for fluent builders
 * Core functionality for builder pattern implementation
 */

/**
 * Unique symbol for identifying fluent builders
 * Used across module boundaries for proper type identification
 */
export const FLUENT_BUILDER_SYMBOL = Symbol.for("fluent-builder");

/**
 * Base context interface for builder operations
 * Provides information about the builder's position in the object hierarchy
 */
export interface BaseBuildContext {
  /** Parent builder identifier */
  readonly parentId?: string;
  /** Name of the parameter being built */
  readonly parameterName?: string;
  /** Index in array if building array elements */
  readonly index?: number;
  /** Additional context properties */
  readonly [key: string]: unknown;
}

/**
 * Core fluent builder interface
 * All generated builders implement this interface
 */
export interface FluentBuilder<T, C extends BaseBuildContext = BaseBuildContext> {
  /** Identifies this as a fluent builder */
  readonly [FLUENT_BUILDER_SYMBOL]: true;
  /**
   * Builds the final object
   * @param context - Optional build context
   */
  build(context?: C): T;
}

/**
 * Type guard to check if a value is a fluent builder
 * Uses Symbol.for to ensure proper identification across module boundaries
 * @param value - Value to check
 * @returns True if value is a fluent builder
 */
export function isFluentBuilder<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is FluentBuilder<T, C> {
  if (value === null || typeof value !== "object") {
    return false;
  }

  // Safely check for symbol property
  const hasSymbol = FLUENT_BUILDER_SYMBOL in value;
  if (!hasSymbol) {
    return false;
  }

  // Type narrowing: at this point we know it's an object with our symbol
  const obj = value as { [FLUENT_BUILDER_SYMBOL]: unknown; build?: unknown };

  return (
    obj[FLUENT_BUILDER_SYMBOL] === true &&
    typeof obj.build === "function"
  );
}

/**
 * Type guard to check if a value is a builder array
 * @param value - Value to check
 * @returns True if value is an array of builders
 */
export function isBuilderArray<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is Array<FluentBuilder<T, C>> {
  return Array.isArray(value) && value.every(isFluentBuilder);
}

/**
 * Creates a new context for nested builders with proper inheritance
 * @param parentContext - Context from parent builder
 * @param parameterName - Name of the parameter being built
 * @param index - Optional array index
 * @returns New context with inherited properties
 */
export function createNestedContext<C extends BaseBuildContext>(
  parentContext: C,
  parameterName: string,
  index?: number,
): C {
  return {
    ...parentContext,
    parameterName,
    index,
  } as C;
}

/**
 * Recursively resolves builders in a value
 * @param value - Value to resolve
 * @param context - Optional build context
 * @returns Resolved value with all builders built
 */
export function resolveValue<T, C extends BaseBuildContext>(
  value: unknown,
  context?: C
): unknown {
  if (isFluentBuilder<T, C>(value)) {
    return value.build(context);
  }

  if (Array.isArray(value)) {
    return value.map((item, index) => {
      const arrayContext = context ? createNestedContext(context, 'array', index) : undefined;
      return resolveValue(item, arrayContext);
    });
  }

  if (value && typeof value === 'object' && value.constructor === Object) {
    const resolved: Record<string, unknown> = {};
    for (const [key, val] of Object.entries(value)) {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      resolved[key] = resolveValue(val, nestedContext);
    }
    return resolved;
  }

  return value;
}

/**
 * Base class for all generated builders
 * Provides core functionality for the builder pattern
 */
export abstract class FluentBuilderBase<T, C extends BaseBuildContext = BaseBuildContext> {
  /** Marks this as a fluent builder */
  readonly [FLUENT_BUILDER_SYMBOL] = true;
  /** Storage for property values */
  protected values: Partial<T> = {};
  /** Storage for nested builders - includes indexed keys for array elements */
  protected builders = new Map<string, FluentBuilder<unknown, C> | unknown>();
  /** Storage for mixed arrays (static values + builders) */
  protected mixedArrays = new Map<string, unknown[]>();
  /** Optional build context */
  protected context?: C;

  /**
   * Creates a new builder instance
   * @param initial - Optional initial values
   */
  constructor(initial?: Partial<T>) {
    if (initial) {
      this.values = { ...initial };
    }
  }

  /**
   * Sets a property value, handling both regular values and nested builders
   * @param key - The property key
   * @param value - The value or builder to set
   */
  protected set<K extends keyof T>(key: K, value: unknown): this {
    const keyStr = String(key);

    if (isFluentBuilder(value)) {
      this.builders.set(keyStr, value);
      // Clear from values if it was there
      delete this.values[key];
    } else if (Array.isArray(value)) {
      // Handle mixed arrays (builders + static values)
      const hasBuilders = value.some((item) => isFluentBuilder(item) ||
        (typeof item === 'object' && item !== null && this.containsBuilder(item)));

      if (hasBuilders) {
        // Store the array for mixed processing
        this.mixedArrays.set(keyStr, value);
        // Store individual builders with indexed keys
        value.forEach((item, index) => {
          if (isFluentBuilder(item)) {
            this.builders.set(\`\${keyStr}[\${index}]\`, item);
          } else if (typeof item === 'object' && item !== null && this.containsBuilder(item)) {
            // Store objects containing builders for recursive resolution
            this.builders.set(\`\${keyStr}[\${index}]\`, item);
          }
        });
        // Clear from values
        delete this.values[key];
      } else {
        // Pure static array
        this.values[key] = value as T[K];
        // Clear from mixed arrays if it was there
        this.mixedArrays.delete(keyStr);
      }
    } else if (typeof value === 'object' && value !== null && this.containsBuilder(value)) {
      // Object containing builders
      this.builders.set(keyStr, value);
      delete this.values[key];
    } else {
      // Static value
      this.values[key] = value as T[K];
      // Clear from builders if it was there
      this.builders.delete(keyStr);
      this.mixedArrays.delete(keyStr);
    }
    return this;
  }

  /**
   * Checks if an object contains any builders recursively
   */
  private containsBuilder(obj: unknown): boolean {
    if (isFluentBuilder(obj)) return true;
    if (Array.isArray(obj)) {
      return obj.some((item) => this.containsBuilder(item));
    }
    if (obj && typeof obj === 'object' && obj.constructor === Object) {
      return Object.values(obj).some((val) => this.containsBuilder(val));
    }
    return false;
  }

  /**
   * Builds the final object with defaults and nested builder resolution
   * @param defaults - Optional default values
   * @param context - Optional build context
   */
  protected buildWithDefaults(defaults?: Partial<T>, context?: C): T {
    const result: Record<string, unknown> = defaults ? { ...defaults } : {};

    // Apply explicitly set values
    Object.assign(result, this.values);

    // Process mixed arrays
    this.mixedArrays.forEach((array, key) => {
      const resolvedArray: unknown[] = [];
      array.forEach((item, index) => {
        const indexedKey = \`\${key}[\${index}]\`;
        const nestedContext = context ? createNestedContext(context, key, index) : undefined;

        // Check if this index has a builder stored
        if (this.builders.has(indexedKey)) {
          const builderOrObj = this.builders.get(indexedKey);
          resolvedArray[index] = resolveValue(builderOrObj, nestedContext);
        } else {
          // Static value
          resolvedArray[index] = item;
        }
      });
      result[key] = resolvedArray;
    });

    // Process regular builders (non-array)
    this.builders.forEach((value, key) => {
      // Skip indexed keys (they're handled in mixed arrays)
      if (key.includes('[')) return;
      // Skip keys that are in mixed arrays
      if (this.mixedArrays.has(key)) return;

      const nestedContext = context ? createNestedContext(context, key) : undefined;
      result[key] = resolveValue(value, nestedContext);
    });

    // Type assertion is safe here as we're building from typed values
    return result as T;
  }

  /**
   * Conditionally sets a property based on a predicate
   * @param predicate - Function to determine if the property should be set
   * @param property - The property key
   * @param value - The value or value generator
   */
  public if<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    value: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>)
  ): this {
    if (predicate(this)) {
      // Type guard: check if it's a function that's not a builder
      const resolvedValue = typeof value === 'function' && !isFluentBuilder(value)
        ? (value as () => T[K] | FluentBuilder<T[K], C>)()
        : value;
      this.set(property, resolvedValue);
    }
    return this;
  }

  /**
   * Conditionally sets a property choosing between two values
   * @param predicate - Function to determine which value to use
   * @param property - The property key
   * @param trueValue - Value to use if predicate is true
   * @param falseValue - Value to use if predicate is false
   */
  public ifElse<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    trueValue: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>),
    falseValue: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>)
  ): this {
    const valueToUse = predicate(this) ? trueValue : falseValue;
    // Type guard: check if it's a function that's not a builder
    const resolvedValue = typeof valueToUse === 'function' && !isFluentBuilder(valueToUse)
      ? (valueToUse as () => T[K] | FluentBuilder<T[K], C>)()
      : valueToUse;
    this.set(property, resolvedValue);
    return this;
  }

  /**
   * Checks if a property has been set
   * @param key - The property key to check
   */
  public has<K extends keyof T>(key: K): boolean {
    const keyStr = String(key);
    return key in this.values || this.builders.has(keyStr) || this.mixedArrays.has(keyStr);
  }

  /**
   * Get current value (useful for conditional logic)
   * @param key - The property key
   * @returns The current value or undefined
   */
  public peek<K extends keyof T>(key: K): T[K] | undefined {
    return this.values[key];
  }

  /**
   * Abstract build method to be implemented by generated builders
   * @param context - Optional build context
   */
  abstract build(context?: C): T;
}

/**
 * Creates an inspect method for better debugging experience
 * @param builderName - Name of the builder class
 * @param properties - Current builder properties
 * @returns Formatted string for inspection
 */
export function createInspectMethod(builderName: string, properties: Record<string, unknown>): string {
  return \`\${builderName} { properties: \${JSON.stringify(properties, null, 2)} }\`;
}",
  },
}
`;
