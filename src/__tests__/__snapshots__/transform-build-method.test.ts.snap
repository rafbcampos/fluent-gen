// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Transform Build Method Plugin Integration > Basic Plugin Functionality > should handle plugin errors gracefully 1`] = `
"
// === Fluent Builder Utilities ===
/**
 * Common utilities for fluent builders
 * Auto-generated - do not modify manually
 */

const FLUENT_BUILDER_SYMBOL = Symbol.for("fluent-builder");

interface BaseBuildContext {
  readonly parentId?: string;
  readonly parameterName?: string;
  readonly index?: number;
  readonly [key: string]: unknown;
}

interface FluentBuilder<T, C extends BaseBuildContext = BaseBuildContext> {
  readonly [FLUENT_BUILDER_SYMBOL]: true;
  build(context?: C): T;
}

function isFluentBuilder<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is FluentBuilder<T, C> {
  if (value === null || typeof value !== "object") {
    return false;
  }

  const hasSymbol = FLUENT_BUILDER_SYMBOL in value;
  if (!hasSymbol) {
    return false;
  }

  const obj = value as { [FLUENT_BUILDER_SYMBOL]: unknown; build?: unknown };

  return (
    obj[FLUENT_BUILDER_SYMBOL] === true &&
    typeof obj.build === "function"
  );
}

function isBuilderArray<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is Array<FluentBuilder<T, C>> {
  return Array.isArray(value) && value.every(isFluentBuilder);
}

function createNestedContext<C extends BaseBuildContext>(
  parentContext: C,
  parameterName: string,
  index?: number,
): C {
  return {
    ...parentContext,
    parameterName,
    index,
  } as C;
}

function resolveValue<T, C extends BaseBuildContext>(
  value: unknown,
  context?: C
): unknown {
  if (isFluentBuilder<T, C>(value)) {
    return value.build(context);
  }

  if (Array.isArray(value)) {
    return value.map((item, index) => {
      const arrayContext = context ? createNestedContext(context, 'array', index) : undefined;
      return resolveValue(item, arrayContext);
    });
  }

  if (value && typeof value === 'object' && value.constructor === Object) {
    const resolved: Record<string, unknown> = {};
    for (const [key, val] of Object.entries(value)) {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      resolved[key] = resolveValue(val, nestedContext);
    }
    return resolved;
  }

  return value;
}

abstract class FluentBuilderBase<T, C extends BaseBuildContext = BaseBuildContext> {
  readonly [FLUENT_BUILDER_SYMBOL] = true;
  protected values: Partial<T> = {};
  protected builders = new Map<string, FluentBuilder<unknown, C> | Array<FluentBuilder<unknown, C>>>();
  protected context?: C;

  constructor(initial?: Partial<T>) {
    if (initial) {
      this.values = { ...initial };
    }
  }

  protected set<K extends keyof T>(key: K, value: unknown): this {
    if (isFluentBuilder(value) || isBuilderArray(value)) {
      this.builders.set(String(key), value);
    } else if (Array.isArray(value)) {
      if (value.some(isFluentBuilder)) {
        this.builders.set(String(key), value);
      } else {
        this.values[key] = value as T[K];
      }
    } else {
      this.values[key] = value as T[K];
    }
    return this;
  }

  protected buildWithDefaults(defaults?: Partial<T>, context?: C): T {
    const result: Record<string, unknown> = defaults ? { ...defaults } : {};

    Object.assign(result, this.values);

    this.builders.forEach((value, key) => {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      result[key] = resolveValue(value, nestedContext);
    });

    return result as T;
  }

  public if<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    value: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>)
  ): this {
    if (predicate(this)) {
      const resolvedValue = typeof value === 'function' && !isFluentBuilder(value)
        ? (value as () => T[K] | FluentBuilder<T[K], C>)()
        : value;
      this.set(property, resolvedValue);
    }
    return this;
  }

  public has<K extends keyof T>(key: K): boolean {
    return key in this.values || this.builders.has(String(key));
  }

  public peek<K extends keyof T>(key: K): T[K] | undefined {
    return this.values[key];
  }

  abstract build(context?: C): T;
}

function createInspectMethod(builderName: string, properties: Record<string, unknown>): string {
  return \`\${builderName} { properties: \${JSON.stringify(properties, null, 2)} }\`;
}


import type { Text, TextStyle } from "./src/__tests__/fixtures/plugin-scenario.ts";

export interface TextBuilderMethods {
  /** Unique identifier */
  withId(value: string): TextBuilder;
  /** Text value */
  withValue(value: string): TextBuilder;
  /** Text styling */
  withStyle(value: TextStyle | FluentBuilder<TextStyle, BaseBuildContext>): TextBuilder;
}

export class TextBuilder extends FluentBuilderBase<Text> implements TextBuilderMethods, FluentBuilder<Text, BaseBuildContext> {
  private static readonly defaults: Record<string, unknown> = { id: "", value: "" };

  constructor(initial?: Partial<Text>) {
    super(initial);
  }

  /** Unique identifier */

  withId(value: string): TextBuilder {
    return this.set("id", value);
  }

  /** Text value */

  withValue(value: string): TextBuilder {
    return this.set("value", value);
  }

  /** Text styling */

  withStyle(value: TextStyle | FluentBuilder<TextStyle, BaseBuildContext>): TextBuilder {
    return this.set("style", value);
  }

  /**
   * Builds the final Text object
   * @param context - Optional build context for nested builders
   */
  build(context?: BaseBuildContext): Text {
    return this.buildWithDefaults(TextBuilder.defaults, context);
  }

  [Symbol.for("nodejs.util.inspect.custom")](): string {
    return createInspectMethod("TextBuilder", this.values);
  }
}

/**
 * Creates a new Text builder
 * @param initial Optional initial values
 * @returns A fluent builder for Text
 */
export function text(initial?: Partial<Text>): TextBuilder {
  return new TextBuilder(initial);
}"
`;

exports[`Transform Build Method Plugin Integration > Basic Plugin Functionality > should support transformBuildMethod hook 1`] = `
"
// === Fluent Builder Utilities ===
/**
 * Common utilities for fluent builders
 * Auto-generated - do not modify manually
 */

const FLUENT_BUILDER_SYMBOL = Symbol.for("fluent-builder");

interface BaseBuildContext {
  readonly parentId?: string;
  readonly parameterName?: string;
  readonly index?: number;
  readonly [key: string]: unknown;
}

interface FluentBuilder<T, C extends BaseBuildContext = BaseBuildContext> {
  readonly [FLUENT_BUILDER_SYMBOL]: true;
  build(context?: C): T;
}

function isFluentBuilder<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is FluentBuilder<T, C> {
  if (value === null || typeof value !== "object") {
    return false;
  }

  const hasSymbol = FLUENT_BUILDER_SYMBOL in value;
  if (!hasSymbol) {
    return false;
  }

  const obj = value as { [FLUENT_BUILDER_SYMBOL]: unknown; build?: unknown };

  return (
    obj[FLUENT_BUILDER_SYMBOL] === true &&
    typeof obj.build === "function"
  );
}

function isBuilderArray<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is Array<FluentBuilder<T, C>> {
  return Array.isArray(value) && value.every(isFluentBuilder);
}

function createNestedContext<C extends BaseBuildContext>(
  parentContext: C,
  parameterName: string,
  index?: number,
): C {
  return {
    ...parentContext,
    parameterName,
    index,
  } as C;
}

function resolveValue<T, C extends BaseBuildContext>(
  value: unknown,
  context?: C
): unknown {
  if (isFluentBuilder<T, C>(value)) {
    return value.build(context);
  }

  if (Array.isArray(value)) {
    return value.map((item, index) => {
      const arrayContext = context ? createNestedContext(context, 'array', index) : undefined;
      return resolveValue(item, arrayContext);
    });
  }

  if (value && typeof value === 'object' && value.constructor === Object) {
    const resolved: Record<string, unknown> = {};
    for (const [key, val] of Object.entries(value)) {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      resolved[key] = resolveValue(val, nestedContext);
    }
    return resolved;
  }

  return value;
}

abstract class FluentBuilderBase<T, C extends BaseBuildContext = BaseBuildContext> {
  readonly [FLUENT_BUILDER_SYMBOL] = true;
  protected values: Partial<T> = {};
  protected builders = new Map<string, FluentBuilder<unknown, C> | Array<FluentBuilder<unknown, C>>>();
  protected context?: C;

  constructor(initial?: Partial<T>) {
    if (initial) {
      this.values = { ...initial };
    }
  }

  protected set<K extends keyof T>(key: K, value: unknown): this {
    if (isFluentBuilder(value) || isBuilderArray(value)) {
      this.builders.set(String(key), value);
    } else if (Array.isArray(value)) {
      if (value.some(isFluentBuilder)) {
        this.builders.set(String(key), value);
      } else {
        this.values[key] = value as T[K];
      }
    } else {
      this.values[key] = value as T[K];
    }
    return this;
  }

  protected buildWithDefaults(defaults?: Partial<T>, context?: C): T {
    const result: Record<string, unknown> = defaults ? { ...defaults } : {};

    Object.assign(result, this.values);

    this.builders.forEach((value, key) => {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      result[key] = resolveValue(value, nestedContext);
    });

    return result as T;
  }

  public if<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    value: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>)
  ): this {
    if (predicate(this)) {
      const resolvedValue = typeof value === 'function' && !isFluentBuilder(value)
        ? (value as () => T[K] | FluentBuilder<T[K], C>)()
        : value;
      this.set(property, resolvedValue);
    }
    return this;
  }

  public has<K extends keyof T>(key: K): boolean {
    return key in this.values || this.builders.has(String(key));
  }

  public peek<K extends keyof T>(key: K): T[K] | undefined {
    return this.values[key];
  }

  abstract build(context?: C): T;
}

function createInspectMethod(builderName: string, properties: Record<string, unknown>): string {
  return \`\${builderName} { properties: \${JSON.stringify(properties, null, 2)} }\`;
}


import type { Text, TextStyle } from "./src/__tests__/fixtures/plugin-scenario.ts";

export interface TextBuilderMethods {
  /** Unique identifier */
  withId(value: string): TextBuilder;
  /** Text value */
  withValue(value: string): TextBuilder;
  /** Text styling */
  withStyle(value: TextStyle | FluentBuilder<TextStyle, BaseBuildContext>): TextBuilder;
}

export class TextBuilder extends FluentBuilderBase<Text> implements TextBuilderMethods, FluentBuilder<Text, BaseBuildContext> {
  private static readonly defaults: Record<string, unknown> = { id: "", value: "" };

  constructor(initial?: Partial<Text>) {
    super(initial);
  }

  /** Unique identifier */

  withId(value: string): TextBuilder {
    return this.set("id", value);
  }

  /** Text value */

  withValue(value: string): TextBuilder {
    return this.set("value", value);
  }

  /** Text styling */

  withStyle(value: TextStyle | FluentBuilder<TextStyle, BaseBuildContext>): TextBuilder {
    return this.set("style", value);
  }

  /**
   * Builds the final Text object
   * @param context - Optional build context for nested builders
   */
  // Enhanced by plugin
  build(context?: BaseBuildContext): Text {
    return this.buildWithDefaults(TextBuilder.defaults, context);
  }

  [Symbol.for("nodejs.util.inspect.custom")](): string {
    return createInspectMethod("TextBuilder", this.values);
  }
}

/**
 * Creates a new Text builder
 * @param initial Optional initial values
 * @returns A fluent builder for Text
 */
export function text(initial?: Partial<Text>): TextBuilder {
  return new TextBuilder(initial);
}"
`;

exports[`Transform Build Method Plugin Integration > Context-Based Plugin Customization > should allow plugins to customize based on any property 1`] = `
"
// === Fluent Builder Utilities ===
/**
 * Common utilities for fluent builders
 * Auto-generated - do not modify manually
 */

const FLUENT_BUILDER_SYMBOL = Symbol.for("fluent-builder");

interface BaseBuildContext {
  readonly parentId?: string;
  readonly parameterName?: string;
  readonly index?: number;
  readonly [key: string]: unknown;
}

interface FluentBuilder<T, C extends BaseBuildContext = BaseBuildContext> {
  readonly [FLUENT_BUILDER_SYMBOL]: true;
  build(context?: C): T;
}

function isFluentBuilder<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is FluentBuilder<T, C> {
  if (value === null || typeof value !== "object") {
    return false;
  }

  const hasSymbol = FLUENT_BUILDER_SYMBOL in value;
  if (!hasSymbol) {
    return false;
  }

  const obj = value as { [FLUENT_BUILDER_SYMBOL]: unknown; build?: unknown };

  return (
    obj[FLUENT_BUILDER_SYMBOL] === true &&
    typeof obj.build === "function"
  );
}

function isBuilderArray<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is Array<FluentBuilder<T, C>> {
  return Array.isArray(value) && value.every(isFluentBuilder);
}

function createNestedContext<C extends BaseBuildContext>(
  parentContext: C,
  parameterName: string,
  index?: number,
): C {
  return {
    ...parentContext,
    parameterName,
    index,
  } as C;
}

function resolveValue<T, C extends BaseBuildContext>(
  value: unknown,
  context?: C
): unknown {
  if (isFluentBuilder<T, C>(value)) {
    return value.build(context);
  }

  if (Array.isArray(value)) {
    return value.map((item, index) => {
      const arrayContext = context ? createNestedContext(context, 'array', index) : undefined;
      return resolveValue(item, arrayContext);
    });
  }

  if (value && typeof value === 'object' && value.constructor === Object) {
    const resolved: Record<string, unknown> = {};
    for (const [key, val] of Object.entries(value)) {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      resolved[key] = resolveValue(val, nestedContext);
    }
    return resolved;
  }

  return value;
}

abstract class FluentBuilderBase<T, C extends BaseBuildContext = BaseBuildContext> {
  readonly [FLUENT_BUILDER_SYMBOL] = true;
  protected values: Partial<T> = {};
  protected builders = new Map<string, FluentBuilder<unknown, C> | Array<FluentBuilder<unknown, C>>>();
  protected context?: C;

  constructor(initial?: Partial<T>) {
    if (initial) {
      this.values = { ...initial };
    }
  }

  protected set<K extends keyof T>(key: K, value: unknown): this {
    if (isFluentBuilder(value) || isBuilderArray(value)) {
      this.builders.set(String(key), value);
    } else if (Array.isArray(value)) {
      if (value.some(isFluentBuilder)) {
        this.builders.set(String(key), value);
      } else {
        this.values[key] = value as T[K];
      }
    } else {
      this.values[key] = value as T[K];
    }
    return this;
  }

  protected buildWithDefaults(defaults?: Partial<T>, context?: C): T {
    const result: Record<string, unknown> = defaults ? { ...defaults } : {};

    Object.assign(result, this.values);

    this.builders.forEach((value, key) => {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      result[key] = resolveValue(value, nestedContext);
    });

    return result as T;
  }

  public if<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    value: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>)
  ): this {
    if (predicate(this)) {
      const resolvedValue = typeof value === 'function' && !isFluentBuilder(value)
        ? (value as () => T[K] | FluentBuilder<T[K], C>)()
        : value;
      this.set(property, resolvedValue);
    }
    return this;
  }

  public has<K extends keyof T>(key: K): boolean {
    return key in this.values || this.builders.has(String(key));
  }

  public peek<K extends keyof T>(key: K): T[K] | undefined {
    return this.values[key];
  }

  abstract build(context?: C): T;
}

function createInspectMethod(builderName: string, properties: Record<string, unknown>): string {
  return \`\${builderName} { properties: \${JSON.stringify(properties, null, 2)} }\`;
}


import type { Text, TextStyle } from "./src/__tests__/fixtures/plugin-scenario.ts";

export interface TextBuilderMethods {
  /** Unique identifier */
  withId(value: string): TextBuilder;
  /** Text value */
  withValue(value: string): TextBuilder;
  /** Text styling */
  withStyle(value: TextStyle | FluentBuilder<TextStyle, BaseBuildContext>): TextBuilder;
}

export class TextBuilder extends FluentBuilderBase<Text> implements TextBuilderMethods, FluentBuilder<Text, BaseBuildContext> {
  private static readonly defaults: Record<string, unknown> = { id: "", value: "" };

  constructor(initial?: Partial<Text>) {
    super(initial);
  }

  /** Unique identifier */

  withId(value: string): TextBuilder {
    return this.set("id", value);
  }

  /** Text value */

  withValue(value: string): TextBuilder {
    return this.set("value", value);
  }

  /** Text styling */

  withStyle(value: TextStyle | FluentBuilder<TextStyle, BaseBuildContext>): TextBuilder {
    return this.set("style", value);
  }

  /**
   * Builds the final Text object
   * @param context - Optional build context for nested builders
   */
  build(context?: BaseBuildContext): Text {
    return this.buildWithDefaults(TextBuilder.defaults, context);
  }

  [Symbol.for("nodejs.util.inspect.custom")](): string {
    return createInspectMethod("TextBuilder", this.values);
  }
}

/**
 * Creates a new Text builder
 * @param initial Optional initial values
 * @returns A fluent builder for Text
 */
export function text(initial?: Partial<Text>): TextBuilder {
  return new TextBuilder(initial);
}"
`;

exports[`Transform Build Method Plugin Integration > Deterministic ID Plugin > should generate complete deterministic ID logic for Action type 1`] = `
"
// === Fluent Builder Utilities ===
/**
 * Common utilities for fluent builders
 * Auto-generated - do not modify manually
 */

const FLUENT_BUILDER_SYMBOL = Symbol.for("fluent-builder");

interface BaseBuildContext {
  readonly parentId?: string;
  readonly parameterName?: string;
  readonly index?: number;
  readonly [key: string]: unknown;
}

interface FluentBuilder<T, C extends BaseBuildContext = BaseBuildContext> {
  readonly [FLUENT_BUILDER_SYMBOL]: true;
  build(context?: C): T;
}

function isFluentBuilder<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is FluentBuilder<T, C> {
  if (value === null || typeof value !== "object") {
    return false;
  }

  const hasSymbol = FLUENT_BUILDER_SYMBOL in value;
  if (!hasSymbol) {
    return false;
  }

  const obj = value as { [FLUENT_BUILDER_SYMBOL]: unknown; build?: unknown };

  return (
    obj[FLUENT_BUILDER_SYMBOL] === true &&
    typeof obj.build === "function"
  );
}

function isBuilderArray<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is Array<FluentBuilder<T, C>> {
  return Array.isArray(value) && value.every(isFluentBuilder);
}

function createNestedContext<C extends BaseBuildContext>(
  parentContext: C,
  parameterName: string,
  index?: number,
): C {
  return {
    ...parentContext,
    parameterName,
    index,
  } as C;
}

function resolveValue<T, C extends BaseBuildContext>(
  value: unknown,
  context?: C
): unknown {
  if (isFluentBuilder<T, C>(value)) {
    return value.build(context);
  }

  if (Array.isArray(value)) {
    return value.map((item, index) => {
      const arrayContext = context ? createNestedContext(context, 'array', index) : undefined;
      return resolveValue(item, arrayContext);
    });
  }

  if (value && typeof value === 'object' && value.constructor === Object) {
    const resolved: Record<string, unknown> = {};
    for (const [key, val] of Object.entries(value)) {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      resolved[key] = resolveValue(val, nestedContext);
    }
    return resolved;
  }

  return value;
}

abstract class FluentBuilderBase<T, C extends BaseBuildContext = BaseBuildContext> {
  readonly [FLUENT_BUILDER_SYMBOL] = true;
  protected values: Partial<T> = {};
  protected builders = new Map<string, FluentBuilder<unknown, C> | Array<FluentBuilder<unknown, C>>>();
  protected context?: C;

  constructor(initial?: Partial<T>) {
    if (initial) {
      this.values = { ...initial };
    }
  }

  protected set<K extends keyof T>(key: K, value: unknown): this {
    if (isFluentBuilder(value) || isBuilderArray(value)) {
      this.builders.set(String(key), value);
    } else if (Array.isArray(value)) {
      if (value.some(isFluentBuilder)) {
        this.builders.set(String(key), value);
      } else {
        this.values[key] = value as T[K];
      }
    } else {
      this.values[key] = value as T[K];
    }
    return this;
  }

  protected buildWithDefaults(defaults?: Partial<T>, context?: C): T {
    const result: Record<string, unknown> = defaults ? { ...defaults } : {};

    Object.assign(result, this.values);

    this.builders.forEach((value, key) => {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      result[key] = resolveValue(value, nestedContext);
    });

    return result as T;
  }

  public if<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    value: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>)
  ): this {
    if (predicate(this)) {
      const resolvedValue = typeof value === 'function' && !isFluentBuilder(value)
        ? (value as () => T[K] | FluentBuilder<T[K], C>)()
        : value;
      this.set(property, resolvedValue);
    }
    return this;
  }

  public has<K extends keyof T>(key: K): boolean {
    return key in this.values || this.builders.has(String(key));
  }

  public peek<K extends keyof T>(key: K): T[K] | undefined {
    return this.values[key];
  }

  abstract build(context?: C): T;
}

function createInspectMethod(builderName: string, properties: Record<string, unknown>): string {
  return \`\${builderName} { properties: \${JSON.stringify(properties, null, 2)} }\`;
}


import type { Action, Text } from "./src/__tests__/fixtures/plugin-scenario.ts";

export interface ActionBuilderMethods {
  /** Unique identifier */
  withId(value: string): ActionBuilder;
  /** Action type */
  withType(value: "navigate" | "submit" | "cancel"): ActionBuilder;
  /** Target URL for navigation */
  withTarget(value: string): ActionBuilder;
  /** Action label */
  withLabel(value: Text | FluentBuilder<Text, BaseBuildContext>): ActionBuilder;
}

export class ActionBuilder extends FluentBuilderBase<Action> implements ActionBuilderMethods, FluentBuilder<Action, BaseBuildContext> {
  private static readonly defaults: Record<string, unknown> = { id: "", type: "navigate" };

  constructor(initial?: Partial<Action>) {
    super(initial);
  }

  /** Unique identifier */

  withId(value: string): ActionBuilder {
    return this.set("id", value);
  }

  /** Action type */

  withType(value: "navigate" | "submit" | "cancel"): ActionBuilder {
    return this.set("type", value);
  }

  /** Target URL for navigation */

  withTarget(value: string): ActionBuilder {
    return this.set("target", value);
  }

  /** Action label */

  withLabel(value: Text | FluentBuilder<Text, BaseBuildContext>): ActionBuilder {
    return this.set("label", value);
  }

  build(context?: BaseBuildContext & { parentId?: string; parameterName?: string; index?: number }): Action {
    // Generate deterministic ID based on context
    const generatedId = this.generateId(context);
    const result = { ...this.values };

    // Set ID if not already provided
    if (!result.id) {
      result.id = generatedId;
    }

    // Build nested components with enhanced context
    const enhancedContext = {
      ...context,
      parentId: generatedId,
    };

    this.builders.forEach((builder, key) => {
      if (Array.isArray(builder)) {
        const arr: Array<unknown> = [];
        builder.forEach((b, index) => {
          const nestedCtx = {
            ...enhancedContext,
            parameterName: key,
            index,
          };
          arr.push(b.build(nestedCtx));
        });
        (result as Record<string, unknown>)[key] = arr;
      } else {
        const nestedCtx = {
          ...enhancedContext,
          parameterName: key,
        };
        (result as Record<string, unknown>)[key] = builder.build(nestedCtx);
      }
    });

    return result as Action;
  }

  private generateId(context?: BaseBuildContext & { parentId?: string; parameterName?: string; index?: number }): string {
    if (!context?.parentId) {
      return "root";
    }

    const parts = [context.parentId, context.parameterName];
    if (context.index !== undefined) {
      parts.push(context.index.toString());
    }

    return parts.join("-");
  }

  [Symbol.for("nodejs.util.inspect.custom")](): string {
    return createInspectMethod("ActionBuilder", this.values);
  }
}

/**
 * Creates a new Action builder
 * @param initial Optional initial values
 * @returns A fluent builder for Action
 */
export function action(initial?: Partial<Action>): ActionBuilder {
  return new ActionBuilder(initial);
}"
`;

exports[`Transform Build Method Plugin Integration > Deterministic ID Plugin > should not modify types without id property 1`] = `
"
// === Fluent Builder Utilities ===
/**
 * Common utilities for fluent builders
 * Auto-generated - do not modify manually
 */

const FLUENT_BUILDER_SYMBOL = Symbol.for("fluent-builder");

interface BaseBuildContext {
  readonly parentId?: string;
  readonly parameterName?: string;
  readonly index?: number;
  readonly [key: string]: unknown;
}

interface FluentBuilder<T, C extends BaseBuildContext = BaseBuildContext> {
  readonly [FLUENT_BUILDER_SYMBOL]: true;
  build(context?: C): T;
}

function isFluentBuilder<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is FluentBuilder<T, C> {
  if (value === null || typeof value !== "object") {
    return false;
  }

  const hasSymbol = FLUENT_BUILDER_SYMBOL in value;
  if (!hasSymbol) {
    return false;
  }

  const obj = value as { [FLUENT_BUILDER_SYMBOL]: unknown; build?: unknown };

  return (
    obj[FLUENT_BUILDER_SYMBOL] === true &&
    typeof obj.build === "function"
  );
}

function isBuilderArray<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is Array<FluentBuilder<T, C>> {
  return Array.isArray(value) && value.every(isFluentBuilder);
}

function createNestedContext<C extends BaseBuildContext>(
  parentContext: C,
  parameterName: string,
  index?: number,
): C {
  return {
    ...parentContext,
    parameterName,
    index,
  } as C;
}

function resolveValue<T, C extends BaseBuildContext>(
  value: unknown,
  context?: C
): unknown {
  if (isFluentBuilder<T, C>(value)) {
    return value.build(context);
  }

  if (Array.isArray(value)) {
    return value.map((item, index) => {
      const arrayContext = context ? createNestedContext(context, 'array', index) : undefined;
      return resolveValue(item, arrayContext);
    });
  }

  if (value && typeof value === 'object' && value.constructor === Object) {
    const resolved: Record<string, unknown> = {};
    for (const [key, val] of Object.entries(value)) {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      resolved[key] = resolveValue(val, nestedContext);
    }
    return resolved;
  }

  return value;
}

abstract class FluentBuilderBase<T, C extends BaseBuildContext = BaseBuildContext> {
  readonly [FLUENT_BUILDER_SYMBOL] = true;
  protected values: Partial<T> = {};
  protected builders = new Map<string, FluentBuilder<unknown, C> | Array<FluentBuilder<unknown, C>>>();
  protected context?: C;

  constructor(initial?: Partial<T>) {
    if (initial) {
      this.values = { ...initial };
    }
  }

  protected set<K extends keyof T>(key: K, value: unknown): this {
    if (isFluentBuilder(value) || isBuilderArray(value)) {
      this.builders.set(String(key), value);
    } else if (Array.isArray(value)) {
      if (value.some(isFluentBuilder)) {
        this.builders.set(String(key), value);
      } else {
        this.values[key] = value as T[K];
      }
    } else {
      this.values[key] = value as T[K];
    }
    return this;
  }

  protected buildWithDefaults(defaults?: Partial<T>, context?: C): T {
    const result: Record<string, unknown> = defaults ? { ...defaults } : {};

    Object.assign(result, this.values);

    this.builders.forEach((value, key) => {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      result[key] = resolveValue(value, nestedContext);
    });

    return result as T;
  }

  public if<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    value: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>)
  ): this {
    if (predicate(this)) {
      const resolvedValue = typeof value === 'function' && !isFluentBuilder(value)
        ? (value as () => T[K] | FluentBuilder<T[K], C>)()
        : value;
      this.set(property, resolvedValue);
    }
    return this;
  }

  public has<K extends keyof T>(key: K): boolean {
    return key in this.values || this.builders.has(String(key));
  }

  public peek<K extends keyof T>(key: K): T[K] | undefined {
    return this.values[key];
  }

  abstract build(context?: C): T;
}

function createInspectMethod(builderName: string, properties: Record<string, unknown>): string {
  return \`\${builderName} { properties: \${JSON.stringify(properties, null, 2)} }\`;
}


import type { SimpleType } from "./src/__tests__/fixtures/plugin-scenario.ts";

export interface SimpleTypeBuilderMethods {
  withValue(value: string): SimpleTypeBuilder;
  withCount(value: number): SimpleTypeBuilder;
}

export class SimpleTypeBuilder extends FluentBuilderBase<SimpleType> implements SimpleTypeBuilderMethods, FluentBuilder<SimpleType, BaseBuildContext> {
  private static readonly defaults: Record<string, unknown> = { value: "" };

  constructor(initial?: Partial<SimpleType>) {
    super(initial);
  }


  withValue(value: string): SimpleTypeBuilder {
    return this.set("value", value);
  }


  withCount(value: number): SimpleTypeBuilder {
    return this.set("count", value);
  }

  /**
   * Builds the final SimpleType object
   * @param context - Optional build context for nested builders
   */
  build(context?: BaseBuildContext): SimpleType {
    return this.buildWithDefaults(SimpleTypeBuilder.defaults, context);
  }

  [Symbol.for("nodejs.util.inspect.custom")](): string {
    return createInspectMethod("SimpleTypeBuilder", this.values);
  }
}

/**
 * Creates a new SimpleType builder
 * @param initial Optional initial values
 * @returns A fluent builder for SimpleType
 */
export function simpleType(initial?: Partial<SimpleType>): SimpleTypeBuilder {
  return new SimpleTypeBuilder(initial);
}"
`;

exports[`Transform Build Method Plugin Integration > Deterministic ID Plugin > should work with complex nested types like Button 1`] = `
"
// === Fluent Builder Utilities ===
/**
 * Common utilities for fluent builders
 * Auto-generated - do not modify manually
 */

const FLUENT_BUILDER_SYMBOL = Symbol.for("fluent-builder");

interface BaseBuildContext {
  readonly parentId?: string;
  readonly parameterName?: string;
  readonly index?: number;
  readonly [key: string]: unknown;
}

interface FluentBuilder<T, C extends BaseBuildContext = BaseBuildContext> {
  readonly [FLUENT_BUILDER_SYMBOL]: true;
  build(context?: C): T;
}

function isFluentBuilder<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is FluentBuilder<T, C> {
  if (value === null || typeof value !== "object") {
    return false;
  }

  const hasSymbol = FLUENT_BUILDER_SYMBOL in value;
  if (!hasSymbol) {
    return false;
  }

  const obj = value as { [FLUENT_BUILDER_SYMBOL]: unknown; build?: unknown };

  return (
    obj[FLUENT_BUILDER_SYMBOL] === true &&
    typeof obj.build === "function"
  );
}

function isBuilderArray<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is Array<FluentBuilder<T, C>> {
  return Array.isArray(value) && value.every(isFluentBuilder);
}

function createNestedContext<C extends BaseBuildContext>(
  parentContext: C,
  parameterName: string,
  index?: number,
): C {
  return {
    ...parentContext,
    parameterName,
    index,
  } as C;
}

function resolveValue<T, C extends BaseBuildContext>(
  value: unknown,
  context?: C
): unknown {
  if (isFluentBuilder<T, C>(value)) {
    return value.build(context);
  }

  if (Array.isArray(value)) {
    return value.map((item, index) => {
      const arrayContext = context ? createNestedContext(context, 'array', index) : undefined;
      return resolveValue(item, arrayContext);
    });
  }

  if (value && typeof value === 'object' && value.constructor === Object) {
    const resolved: Record<string, unknown> = {};
    for (const [key, val] of Object.entries(value)) {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      resolved[key] = resolveValue(val, nestedContext);
    }
    return resolved;
  }

  return value;
}

abstract class FluentBuilderBase<T, C extends BaseBuildContext = BaseBuildContext> {
  readonly [FLUENT_BUILDER_SYMBOL] = true;
  protected values: Partial<T> = {};
  protected builders = new Map<string, FluentBuilder<unknown, C> | Array<FluentBuilder<unknown, C>>>();
  protected context?: C;

  constructor(initial?: Partial<T>) {
    if (initial) {
      this.values = { ...initial };
    }
  }

  protected set<K extends keyof T>(key: K, value: unknown): this {
    if (isFluentBuilder(value) || isBuilderArray(value)) {
      this.builders.set(String(key), value);
    } else if (Array.isArray(value)) {
      if (value.some(isFluentBuilder)) {
        this.builders.set(String(key), value);
      } else {
        this.values[key] = value as T[K];
      }
    } else {
      this.values[key] = value as T[K];
    }
    return this;
  }

  protected buildWithDefaults(defaults?: Partial<T>, context?: C): T {
    const result: Record<string, unknown> = defaults ? { ...defaults } : {};

    Object.assign(result, this.values);

    this.builders.forEach((value, key) => {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      result[key] = resolveValue(value, nestedContext);
    });

    return result as T;
  }

  public if<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    value: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>)
  ): this {
    if (predicate(this)) {
      const resolvedValue = typeof value === 'function' && !isFluentBuilder(value)
        ? (value as () => T[K] | FluentBuilder<T[K], C>)()
        : value;
      this.set(property, resolvedValue);
    }
    return this;
  }

  public has<K extends keyof T>(key: K): boolean {
    return key in this.values || this.builders.has(String(key));
  }

  public peek<K extends keyof T>(key: K): T[K] | undefined {
    return this.values[key];
  }

  abstract build(context?: C): T;
}

function createInspectMethod(builderName: string, properties: Record<string, unknown>): string {
  return \`\${builderName} { properties: \${JSON.stringify(properties, null, 2)} }\`;
}


import type { Button, Text, Action } from "./src/__tests__/fixtures/plugin-scenario.ts";

export interface ButtonBuilderMethods {
  /** Unique identifier */
  withId(value: string): ButtonBuilder;
  /** Button text */
  withLabel(value: Text | FluentBuilder<Text, BaseBuildContext>): ButtonBuilder;
  /** Click action */
  withAction(value: Action | FluentBuilder<Action, BaseBuildContext>): ButtonBuilder;
  /** Button variant */
  withVariant(value: "primary" | "secondary" | "danger"): ButtonBuilder;
}

export class ButtonBuilder extends FluentBuilderBase<Button> implements ButtonBuilderMethods, FluentBuilder<Button, BaseBuildContext> {
  private static readonly defaults: Record<string, unknown> = { id: "", variant: "primary" };

  constructor(initial?: Partial<Button>) {
    super(initial);
  }

  /** Unique identifier */

  withId(value: string): ButtonBuilder {
    return this.set("id", value);
  }

  /** Button text */

  withLabel(value: Text | FluentBuilder<Text, BaseBuildContext>): ButtonBuilder {
    return this.set("label", value);
  }

  /** Click action */

  withAction(value: Action | FluentBuilder<Action, BaseBuildContext>): ButtonBuilder {
    return this.set("action", value);
  }

  /** Button variant */

  withVariant(value: "primary" | "secondary" | "danger"): ButtonBuilder {
    return this.set("variant", value);
  }

  build(context?: BaseBuildContext & { parentId?: string; parameterName?: string; index?: number }): Button {
    // Generate deterministic ID based on context
    const generatedId = this.generateId(context);
    const result = { ...this.values };

    // Set ID if not already provided
    if (!result.id) {
      result.id = generatedId;
    }

    // Build nested components with enhanced context
    const enhancedContext = {
      ...context,
      parentId: generatedId,
    };

    this.builders.forEach((builder, key) => {
      if (Array.isArray(builder)) {
        const arr: Array<unknown> = [];
        builder.forEach((b, index) => {
          const nestedCtx = {
            ...enhancedContext,
            parameterName: key,
            index,
          };
          arr.push(b.build(nestedCtx));
        });
        (result as Record<string, unknown>)[key] = arr;
      } else {
        const nestedCtx = {
          ...enhancedContext,
          parameterName: key,
        };
        (result as Record<string, unknown>)[key] = builder.build(nestedCtx);
      }
    });

    return result as Button;
  }

  private generateId(context?: BaseBuildContext & { parentId?: string; parameterName?: string; index?: number }): string {
    if (!context?.parentId) {
      return "root";
    }

    const parts = [context.parentId, context.parameterName];
    if (context.index !== undefined) {
      parts.push(context.index.toString());
    }

    return parts.join("-");
  }

  [Symbol.for("nodejs.util.inspect.custom")](): string {
    return createInspectMethod("ButtonBuilder", this.values);
  }
}

/**
 * Creates a new Button builder
 * @param initial Optional initial values
 * @returns A fluent builder for Button
 */
export function button(initial?: Partial<Button>): ButtonBuilder {
  return new ButtonBuilder(initial);
}"
`;
