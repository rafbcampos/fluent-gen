// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`FluentGen Integration > Builder Generation > should generate builder for simple interface 1`] = `
{
  "ok": true,
  "value": "
// === Fluent Builder Utilities ===
/**
 * Common utilities for fluent builders
 * Auto-generated - do not modify manually
 */

const FLUENT_BUILDER_SYMBOL = Symbol.for("fluent-builder");

interface BaseBuildContext {
  readonly parentId?: string;
  readonly parameterName?: string;
  readonly index?: number;
  readonly [key: string]: unknown;
}

interface FluentBuilder<T, C extends BaseBuildContext = BaseBuildContext> {
  readonly [FLUENT_BUILDER_SYMBOL]: true;
  build(context?: C): T;
}

function isFluentBuilder<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is FluentBuilder<T, C> {
  if (value === null || typeof value !== "object") {
    return false;
  }

  const hasSymbol = FLUENT_BUILDER_SYMBOL in value;
  if (!hasSymbol) {
    return false;
  }

  const obj = value as { [FLUENT_BUILDER_SYMBOL]: unknown; build?: unknown };

  return (
    obj[FLUENT_BUILDER_SYMBOL] === true &&
    typeof obj.build === "function"
  );
}

function isBuilderArray<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is Array<FluentBuilder<T, C>> {
  return Array.isArray(value) && value.every(isFluentBuilder);
}

function createNestedContext<C extends BaseBuildContext>(
  parentContext: C,
  parameterName: string,
  index?: number,
): C {
  return {
    ...parentContext,
    parameterName,
    index,
  } as C;
}

function resolveValue<T, C extends BaseBuildContext>(
  value: unknown,
  context?: C
): unknown {
  if (isFluentBuilder<T, C>(value)) {
    return value.build(context);
  }

  if (Array.isArray(value)) {
    return value.map((item, index) => {
      const arrayContext = context ? createNestedContext(context, 'array', index) : undefined;
      return resolveValue(item, arrayContext);
    });
  }

  if (value && typeof value === 'object' && value.constructor === Object) {
    const resolved: Record<string, unknown> = {};
    for (const [key, val] of Object.entries(value)) {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      resolved[key] = resolveValue(val, nestedContext);
    }
    return resolved;
  }

  return value;
}

abstract class FluentBuilderBase<T, C extends BaseBuildContext = BaseBuildContext> {
  readonly [FLUENT_BUILDER_SYMBOL] = true;
  protected values: Partial<T> = {};
  protected builders = new Map<string, FluentBuilder<unknown, C> | Array<FluentBuilder<unknown, C>>>();
  protected context?: C;

  constructor(initial?: Partial<T>) {
    if (initial) {
      this.values = { ...initial };
    }
  }

  protected set<K extends keyof T>(key: K, value: unknown): this {
    if (isFluentBuilder(value) || isBuilderArray(value)) {
      this.builders.set(String(key), value);
    } else if (Array.isArray(value)) {
      if (value.some(isFluentBuilder)) {
        this.builders.set(String(key), value);
      } else {
        this.values[key] = value as T[K];
      }
    } else {
      this.values[key] = value as T[K];
    }
    return this;
  }

  protected buildWithDefaults(defaults?: Partial<T>, context?: C): T {
    const result: Record<string, unknown> = defaults ? { ...defaults } : {};

    Object.assign(result, this.values);

    this.builders.forEach((value, key) => {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      result[key] = resolveValue(value, nestedContext);
    });

    return result as T;
  }

  public if<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    value: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>)
  ): this {
    if (predicate(this)) {
      const resolvedValue = typeof value === 'function' && !isFluentBuilder(value)
        ? (value as () => T[K] | FluentBuilder<T[K], C>)()
        : value;
      this.set(property, resolvedValue);
    }
    return this;
  }

  public has<K extends keyof T>(key: K): boolean {
    return key in this.values || this.builders.has(String(key));
  }

  public peek<K extends keyof T>(key: K): T[K] | undefined {
    return this.values[key];
  }

  abstract build(context?: C): T;
}

function createInspectMethod(builderName: string, properties: Record<string, unknown>): string {
  return \`\${builderName} { properties: \${JSON.stringify(properties, null, 2)} }\`;
}


import type { Address } from "./src/__tests__/fixtures/simple.ts";

export interface AddressBuilderMethods {
  /** Street name */
  withStreet(value: string): AddressBuilder;
  /** City name */
  withCity(value: string): AddressBuilder;
  /** Country code */
  withCountry(value: string): AddressBuilder;
}

export class AddressBuilder extends FluentBuilderBase<Address> implements AddressBuilderMethods, FluentBuilder<Address, BaseBuildContext> {
  private static readonly defaults: Record<string, unknown> = { street: "", city: "", country: "" };

  constructor(initial?: Partial<Address>) {
    super(initial);
  }

  /** Street name */

  withStreet(value: string): AddressBuilder {
    return this.set("street", value);
  }

  /** City name */

  withCity(value: string): AddressBuilder {
    return this.set("city", value);
  }

  /** Country code */

  withCountry(value: string): AddressBuilder {
    return this.set("country", value);
  }

  /**
   * Builds the final Address object
   * @param context - Optional build context for nested builders
   */
  build(context?: BaseBuildContext): Address {
    return this.buildWithDefaults(AddressBuilder.defaults, context);
  }

  [Symbol.for("nodejs.util.inspect.custom")](): string {
    return createInspectMethod("AddressBuilder", this.values);
  }
}

/**
 * Creates a new Address builder
 * @param initial Optional initial values
 * @returns A fluent builder for Address
 */
export function address(initial?: Partial<Address>): AddressBuilder {
  return new AddressBuilder(initial);
}",
}
`;

exports[`FluentGen Integration > Builder Generation > should generate builder with generics 1`] = `
{
  "ok": true,
  "value": "
// === Fluent Builder Utilities ===
/**
 * Common utilities for fluent builders
 * Auto-generated - do not modify manually
 */

const FLUENT_BUILDER_SYMBOL = Symbol.for("fluent-builder");

interface BaseBuildContext {
  readonly parentId?: string;
  readonly parameterName?: string;
  readonly index?: number;
  readonly [key: string]: unknown;
}

interface FluentBuilder<T, C extends BaseBuildContext = BaseBuildContext> {
  readonly [FLUENT_BUILDER_SYMBOL]: true;
  build(context?: C): T;
}

function isFluentBuilder<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is FluentBuilder<T, C> {
  if (value === null || typeof value !== "object") {
    return false;
  }

  const hasSymbol = FLUENT_BUILDER_SYMBOL in value;
  if (!hasSymbol) {
    return false;
  }

  const obj = value as { [FLUENT_BUILDER_SYMBOL]: unknown; build?: unknown };

  return (
    obj[FLUENT_BUILDER_SYMBOL] === true &&
    typeof obj.build === "function"
  );
}

function isBuilderArray<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is Array<FluentBuilder<T, C>> {
  return Array.isArray(value) && value.every(isFluentBuilder);
}

function createNestedContext<C extends BaseBuildContext>(
  parentContext: C,
  parameterName: string,
  index?: number,
): C {
  return {
    ...parentContext,
    parameterName,
    index,
  } as C;
}

function resolveValue<T, C extends BaseBuildContext>(
  value: unknown,
  context?: C
): unknown {
  if (isFluentBuilder<T, C>(value)) {
    return value.build(context);
  }

  if (Array.isArray(value)) {
    return value.map((item, index) => {
      const arrayContext = context ? createNestedContext(context, 'array', index) : undefined;
      return resolveValue(item, arrayContext);
    });
  }

  if (value && typeof value === 'object' && value.constructor === Object) {
    const resolved: Record<string, unknown> = {};
    for (const [key, val] of Object.entries(value)) {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      resolved[key] = resolveValue(val, nestedContext);
    }
    return resolved;
  }

  return value;
}

abstract class FluentBuilderBase<T, C extends BaseBuildContext = BaseBuildContext> {
  readonly [FLUENT_BUILDER_SYMBOL] = true;
  protected values: Partial<T> = {};
  protected builders = new Map<string, FluentBuilder<unknown, C> | Array<FluentBuilder<unknown, C>>>();
  protected context?: C;

  constructor(initial?: Partial<T>) {
    if (initial) {
      this.values = { ...initial };
    }
  }

  protected set<K extends keyof T>(key: K, value: unknown): this {
    if (isFluentBuilder(value) || isBuilderArray(value)) {
      this.builders.set(String(key), value);
    } else if (Array.isArray(value)) {
      if (value.some(isFluentBuilder)) {
        this.builders.set(String(key), value);
      } else {
        this.values[key] = value as T[K];
      }
    } else {
      this.values[key] = value as T[K];
    }
    return this;
  }

  protected buildWithDefaults(defaults?: Partial<T>, context?: C): T {
    const result: Record<string, unknown> = defaults ? { ...defaults } : {};

    Object.assign(result, this.values);

    this.builders.forEach((value, key) => {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      result[key] = resolveValue(value, nestedContext);
    });

    return result as T;
  }

  public if<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    value: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>)
  ): this {
    if (predicate(this)) {
      const resolvedValue = typeof value === 'function' && !isFluentBuilder(value)
        ? (value as () => T[K] | FluentBuilder<T[K], C>)()
        : value;
      this.set(property, resolvedValue);
    }
    return this;
  }

  public has<K extends keyof T>(key: K): boolean {
    return key in this.values || this.builders.has(String(key));
  }

  public peek<K extends keyof T>(key: K): T[K] | undefined {
    return this.values[key];
  }

  abstract build(context?: C): T;
}

function createInspectMethod(builderName: string, properties: Record<string, unknown>): string {
  return \`\${builderName} { properties: \${JSON.stringify(properties, null, 2)} }\`;
}


import type { ApiResponse, User } from "./src/__tests__/fixtures/simple.ts";

export interface ApiResponseBuilderMethods<T = any, U extends User = User> {
  withData(value: T): ApiResponseBuilder<T, U>;
  withError(value: string): ApiResponseBuilder<T, U>;
  withUser(value: U): ApiResponseBuilder<T, U>;
  withTimestamp(value: number): ApiResponseBuilder<T, U>;
}

export class ApiResponseBuilder<T = any, U extends User = User> extends FluentBuilderBase<ApiResponse<T, U>> implements ApiResponseBuilderMethods<T, U>, FluentBuilder<ApiResponse<T, U>, BaseBuildContext> {
  private static readonly defaults: Record<string, unknown> = { timestamp: 0 };

  constructor(initial?: Partial<ApiResponse<T, U>>) {
    super(initial);
  }


  withData(value: T): ApiResponseBuilder<T, U> {
    return this.set("data", value);
  }


  withError(value: string): ApiResponseBuilder<T, U> {
    return this.set("error", value);
  }


  withUser(value: U): ApiResponseBuilder<T, U> {
    return this.set("user", value);
  }


  withTimestamp(value: number): ApiResponseBuilder<T, U> {
    return this.set("timestamp", value);
  }

  /**
   * Builds the final ApiResponse object
   * @param context - Optional build context for nested builders
   */
  build(context?: BaseBuildContext): ApiResponse<T, U> {
    return this.buildWithDefaults(ApiResponseBuilder.defaults, context);
  }

  [Symbol.for("nodejs.util.inspect.custom")](): string {
    return createInspectMethod("ApiResponseBuilder", this.values);
  }
}

/**
 * Creates a new ApiResponse builder
 * @param initial Optional initial values
 * @returns A fluent builder for ApiResponse
 */
export function apiResponse<T = any, U extends User = User>(initial?: Partial<ApiResponse<T, U>>): ApiResponseBuilder<T, U> {
  return new ApiResponseBuilder<T, U>(initial);
}",
}
`;

exports[`FluentGen Integration > Builder Generation > should generate builder with optional properties 1`] = `
{
  "ok": true,
  "value": "
// === Fluent Builder Utilities ===
/**
 * Common utilities for fluent builders
 * Auto-generated - do not modify manually
 */

const FLUENT_BUILDER_SYMBOL = Symbol.for("fluent-builder");

interface BaseBuildContext {
  readonly parentId?: string;
  readonly parameterName?: string;
  readonly index?: number;
  readonly [key: string]: unknown;
}

interface FluentBuilder<T, C extends BaseBuildContext = BaseBuildContext> {
  readonly [FLUENT_BUILDER_SYMBOL]: true;
  build(context?: C): T;
}

function isFluentBuilder<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is FluentBuilder<T, C> {
  if (value === null || typeof value !== "object") {
    return false;
  }

  const hasSymbol = FLUENT_BUILDER_SYMBOL in value;
  if (!hasSymbol) {
    return false;
  }

  const obj = value as { [FLUENT_BUILDER_SYMBOL]: unknown; build?: unknown };

  return (
    obj[FLUENT_BUILDER_SYMBOL] === true &&
    typeof obj.build === "function"
  );
}

function isBuilderArray<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is Array<FluentBuilder<T, C>> {
  return Array.isArray(value) && value.every(isFluentBuilder);
}

function createNestedContext<C extends BaseBuildContext>(
  parentContext: C,
  parameterName: string,
  index?: number,
): C {
  return {
    ...parentContext,
    parameterName,
    index,
  } as C;
}

function resolveValue<T, C extends BaseBuildContext>(
  value: unknown,
  context?: C
): unknown {
  if (isFluentBuilder<T, C>(value)) {
    return value.build(context);
  }

  if (Array.isArray(value)) {
    return value.map((item, index) => {
      const arrayContext = context ? createNestedContext(context, 'array', index) : undefined;
      return resolveValue(item, arrayContext);
    });
  }

  if (value && typeof value === 'object' && value.constructor === Object) {
    const resolved: Record<string, unknown> = {};
    for (const [key, val] of Object.entries(value)) {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      resolved[key] = resolveValue(val, nestedContext);
    }
    return resolved;
  }

  return value;
}

abstract class FluentBuilderBase<T, C extends BaseBuildContext = BaseBuildContext> {
  readonly [FLUENT_BUILDER_SYMBOL] = true;
  protected values: Partial<T> = {};
  protected builders = new Map<string, FluentBuilder<unknown, C> | Array<FluentBuilder<unknown, C>>>();
  protected context?: C;

  constructor(initial?: Partial<T>) {
    if (initial) {
      this.values = { ...initial };
    }
  }

  protected set<K extends keyof T>(key: K, value: unknown): this {
    if (isFluentBuilder(value) || isBuilderArray(value)) {
      this.builders.set(String(key), value);
    } else if (Array.isArray(value)) {
      if (value.some(isFluentBuilder)) {
        this.builders.set(String(key), value);
      } else {
        this.values[key] = value as T[K];
      }
    } else {
      this.values[key] = value as T[K];
    }
    return this;
  }

  protected buildWithDefaults(defaults?: Partial<T>, context?: C): T {
    const result: Record<string, unknown> = defaults ? { ...defaults } : {};

    Object.assign(result, this.values);

    this.builders.forEach((value, key) => {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      result[key] = resolveValue(value, nestedContext);
    });

    return result as T;
  }

  public if<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    value: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>)
  ): this {
    if (predicate(this)) {
      const resolvedValue = typeof value === 'function' && !isFluentBuilder(value)
        ? (value as () => T[K] | FluentBuilder<T[K], C>)()
        : value;
      this.set(property, resolvedValue);
    }
    return this;
  }

  public has<K extends keyof T>(key: K): boolean {
    return key in this.values || this.builders.has(String(key));
  }

  public peek<K extends keyof T>(key: K): T[K] | undefined {
    return this.values[key];
  }

  abstract build(context?: C): T;
}

function createInspectMethod(builderName: string, properties: Record<string, unknown>): string {
  return \`\${builderName} { properties: \${JSON.stringify(properties, null, 2)} }\`;
}


import type { Point } from "./src/__tests__/fixtures/simple.ts";

export interface PointBuilderMethods {
  withX(value: number): PointBuilder;
  withY(value: number): PointBuilder;
  withZ(value: number): PointBuilder;
}

export class PointBuilder extends FluentBuilderBase<Point> implements PointBuilderMethods, FluentBuilder<Point, BaseBuildContext> {
  private static readonly defaults: Record<string, unknown> = { x: 0, y: 0 };

  constructor(initial?: Partial<Point>) {
    super(initial);
  }


  withX(value: number): PointBuilder {
    return this.set("x", value);
  }


  withY(value: number): PointBuilder {
    return this.set("y", value);
  }


  withZ(value: number): PointBuilder {
    return this.set("z", value);
  }

  /**
   * Builds the final Point object
   * @param context - Optional build context for nested builders
   */
  build(context?: BaseBuildContext): Point {
    return this.buildWithDefaults(PointBuilder.defaults, context);
  }

  [Symbol.for("nodejs.util.inspect.custom")](): string {
    return createInspectMethod("PointBuilder", this.values);
  }
}

/**
 * Creates a new Point builder
 * @param initial Optional initial values
 * @returns A fluent builder for Point
 */
export function point(initial?: Partial<Point>): PointBuilder {
  return new PointBuilder(initial);
}",
}
`;

exports[`FluentGen Integration > Builder Generation > should generate multiple builders 1`] = `
{
  "ok": true,
  "value": Map {
    "common.ts" => "/**
 * Common utilities for fluent builders
 * Auto-generated - do not modify manually
 */

export const FLUENT_BUILDER_SYMBOL = Symbol.for("fluent-builder");

export interface BaseBuildContext {
  readonly parentId?: string;
  readonly parameterName?: string;
  readonly index?: number;
  readonly [key: string]: unknown;
}

export interface FluentBuilder<T, C extends BaseBuildContext = BaseBuildContext> {
  readonly [FLUENT_BUILDER_SYMBOL]: true;
  build(context?: C): T;
}

export function isFluentBuilder<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is FluentBuilder<T, C> {
  if (value === null || typeof value !== "object") {
    return false;
  }

  const hasSymbol = FLUENT_BUILDER_SYMBOL in value;
  if (!hasSymbol) {
    return false;
  }

  const obj = value as { [FLUENT_BUILDER_SYMBOL]: unknown; build?: unknown };

  return (
    obj[FLUENT_BUILDER_SYMBOL] === true &&
    typeof obj.build === "function"
  );
}

export function isBuilderArray<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is Array<FluentBuilder<T, C>> {
  return Array.isArray(value) && value.every(isFluentBuilder);
}

export function createNestedContext<C extends BaseBuildContext>(
  parentContext: C,
  parameterName: string,
  index?: number,
): C {
  return {
    ...parentContext,
    parameterName,
    index,
  } as C;
}

export function resolveValue<T, C extends BaseBuildContext>(
  value: unknown,
  context?: C
): unknown {
  if (isFluentBuilder<T, C>(value)) {
    return value.build(context);
  }

  if (Array.isArray(value)) {
    return value.map((item, index) => {
      const arrayContext = context ? createNestedContext(context, 'array', index) : undefined;
      return resolveValue(item, arrayContext);
    });
  }

  if (value && typeof value === 'object' && value.constructor === Object) {
    const resolved: Record<string, unknown> = {};
    for (const [key, val] of Object.entries(value)) {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      resolved[key] = resolveValue(val, nestedContext);
    }
    return resolved;
  }

  return value;
}

export abstract class FluentBuilderBase<T, C extends BaseBuildContext = BaseBuildContext> {
  readonly [FLUENT_BUILDER_SYMBOL] = true;
  protected values: Partial<T> = {};
  protected builders = new Map<string, FluentBuilder<unknown, C> | Array<FluentBuilder<unknown, C>>>();
  protected context?: C;

  constructor(initial?: Partial<T>) {
    if (initial) {
      this.values = { ...initial };
    }
  }

  protected set<K extends keyof T>(key: K, value: unknown): this {
    if (isFluentBuilder(value) || isBuilderArray(value)) {
      this.builders.set(String(key), value);
    } else if (Array.isArray(value)) {
      if (value.some(isFluentBuilder)) {
        this.builders.set(String(key), value);
      } else {
        this.values[key] = value as T[K];
      }
    } else {
      this.values[key] = value as T[K];
    }
    return this;
  }

  protected buildWithDefaults(defaults?: Partial<T>, context?: C): T {
    const result: Record<string, unknown> = defaults ? { ...defaults } : {};

    Object.assign(result, this.values);

    this.builders.forEach((value, key) => {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      result[key] = resolveValue(value, nestedContext);
    });

    return result as T;
  }

  public if<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    value: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>)
  ): this {
    if (predicate(this)) {
      const resolvedValue = typeof value === 'function' && !isFluentBuilder(value)
        ? (value as () => T[K] | FluentBuilder<T[K], C>)()
        : value;
      this.set(property, resolvedValue);
    }
    return this;
  }

  public has<K extends keyof T>(key: K): boolean {
    return key in this.values || this.builders.has(String(key));
  }

  public peek<K extends keyof T>(key: K): T[K] | undefined {
    return this.values[key];
  }

  abstract build(context?: C): T;
}

export function createInspectMethod(builderName: string, properties: Record<string, unknown>): string {
  return \`\${builderName} { properties: \${JSON.stringify(properties, null, 2)} }\`;
}",
    "Address.ts" => "import {
  FluentBuilder,
  FluentBuilderBase,
  BaseBuildContext,
  FLUENT_BUILDER_SYMBOL,
  createInspectMethod
} from "./common.js";
import type { Address } from "./src/__tests__/fixtures/simple.ts";

export interface AddressBuilderMethods {
  /** Street name */
  withStreet(value: string): AddressBuilder;
  /** City name */
  withCity(value: string): AddressBuilder;
  /** Country code */
  withCountry(value: string): AddressBuilder;
}

export class AddressBuilder extends FluentBuilderBase<Address> implements AddressBuilderMethods, FluentBuilder<Address, BaseBuildContext> {
  private static readonly defaults: Record<string, unknown> = { street: "", city: "", country: "" };

  constructor(initial?: Partial<Address>) {
    super(initial);
  }

  /** Street name */

  withStreet(value: string): AddressBuilder {
    return this.set("street", value);
  }

  /** City name */

  withCity(value: string): AddressBuilder {
    return this.set("city", value);
  }

  /** Country code */

  withCountry(value: string): AddressBuilder {
    return this.set("country", value);
  }

  /**
   * Builds the final Address object
   * @param context - Optional build context for nested builders
   */
  build(context?: BaseBuildContext): Address {
    return this.buildWithDefaults(AddressBuilder.defaults, context);
  }

  [Symbol.for("nodejs.util.inspect.custom")](): string {
    return createInspectMethod("AddressBuilder", this.values);
  }
}

/**
 * Creates a new Address builder
 * @param initial Optional initial values
 * @returns A fluent builder for Address
 */
export function address(initial?: Partial<Address>): AddressBuilder {
  return new AddressBuilder(initial);
}",
    "User.ts" => "import {
  FluentBuilder,
  FluentBuilderBase,
  BaseBuildContext,
  FLUENT_BUILDER_SYMBOL,
  createInspectMethod
} from "./common.js";
import type { User, Address } from "./src/__tests__/fixtures/simple.ts";

export interface UserBuilderMethods {
  /** Unique identifier */
  withId(value: string): UserBuilder;
  /** Full name */
  withName(value: string): UserBuilder;
  /** Age in years */
  withAge(value: number): UserBuilder;
  /** User address */
  withAddress(value: Address | FluentBuilder<Address, BaseBuildContext>): UserBuilder;
}

export class UserBuilder extends FluentBuilderBase<User> implements UserBuilderMethods, FluentBuilder<User, BaseBuildContext> {
  private static readonly defaults: Record<string, unknown> = { id: "", name: "" };

  constructor(initial?: Partial<User>) {
    super(initial);
  }

  /** Unique identifier */

  withId(value: string): UserBuilder {
    return this.set("id", value);
  }

  /** Full name */

  withName(value: string): UserBuilder {
    return this.set("name", value);
  }

  /** Age in years */

  withAge(value: number): UserBuilder {
    return this.set("age", value);
  }

  /** User address */

  withAddress(value: Address | FluentBuilder<Address, BaseBuildContext>): UserBuilder {
    return this.set("address", value);
  }

  /**
   * Builds the final User object
   * @param context - Optional build context for nested builders
   */
  build(context?: BaseBuildContext): User {
    return this.buildWithDefaults(UserBuilder.defaults, context);
  }

  [Symbol.for("nodejs.util.inspect.custom")](): string {
    return createInspectMethod("UserBuilder", this.values);
  }
}

/**
 * Creates a new User builder
 * @param initial Optional initial values
 * @returns A fluent builder for User
 */
export function user(initial?: Partial<User>): UserBuilder {
  return new UserBuilder(initial);
}",
    "Point.ts" => "import {
  FluentBuilder,
  FluentBuilderBase,
  BaseBuildContext,
  FLUENT_BUILDER_SYMBOL,
  createInspectMethod
} from "./common.js";
import type { Point } from "./src/__tests__/fixtures/simple.ts";

export interface PointBuilderMethods {
  withX(value: number): PointBuilder;
  withY(value: number): PointBuilder;
  withZ(value: number): PointBuilder;
}

export class PointBuilder extends FluentBuilderBase<Point> implements PointBuilderMethods, FluentBuilder<Point, BaseBuildContext> {
  private static readonly defaults: Record<string, unknown> = { x: 0, y: 0 };

  constructor(initial?: Partial<Point>) {
    super(initial);
  }


  withX(value: number): PointBuilder {
    return this.set("x", value);
  }


  withY(value: number): PointBuilder {
    return this.set("y", value);
  }


  withZ(value: number): PointBuilder {
    return this.set("z", value);
  }

  /**
   * Builds the final Point object
   * @param context - Optional build context for nested builders
   */
  build(context?: BaseBuildContext): Point {
    return this.buildWithDefaults(PointBuilder.defaults, context);
  }

  [Symbol.for("nodejs.util.inspect.custom")](): string {
    return createInspectMethod("PointBuilder", this.values);
  }
}

/**
 * Creates a new Point builder
 * @param initial Optional initial values
 * @returns A fluent builder for Point
 */
export function point(initial?: Partial<Point>): PointBuilder {
  return new PointBuilder(initial);
}",
  },
}
`;

exports[`FluentGen Integration > Builder Generation > should handle nested builders 1`] = `
{
  "ok": true,
  "value": "
// === Fluent Builder Utilities ===
/**
 * Common utilities for fluent builders
 * Auto-generated - do not modify manually
 */

const FLUENT_BUILDER_SYMBOL = Symbol.for("fluent-builder");

interface BaseBuildContext {
  readonly parentId?: string;
  readonly parameterName?: string;
  readonly index?: number;
  readonly [key: string]: unknown;
}

interface FluentBuilder<T, C extends BaseBuildContext = BaseBuildContext> {
  readonly [FLUENT_BUILDER_SYMBOL]: true;
  build(context?: C): T;
}

function isFluentBuilder<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is FluentBuilder<T, C> {
  if (value === null || typeof value !== "object") {
    return false;
  }

  const hasSymbol = FLUENT_BUILDER_SYMBOL in value;
  if (!hasSymbol) {
    return false;
  }

  const obj = value as { [FLUENT_BUILDER_SYMBOL]: unknown; build?: unknown };

  return (
    obj[FLUENT_BUILDER_SYMBOL] === true &&
    typeof obj.build === "function"
  );
}

function isBuilderArray<T = unknown, C extends BaseBuildContext = BaseBuildContext>(
  value: unknown,
): value is Array<FluentBuilder<T, C>> {
  return Array.isArray(value) && value.every(isFluentBuilder);
}

function createNestedContext<C extends BaseBuildContext>(
  parentContext: C,
  parameterName: string,
  index?: number,
): C {
  return {
    ...parentContext,
    parameterName,
    index,
  } as C;
}

function resolveValue<T, C extends BaseBuildContext>(
  value: unknown,
  context?: C
): unknown {
  if (isFluentBuilder<T, C>(value)) {
    return value.build(context);
  }

  if (Array.isArray(value)) {
    return value.map((item, index) => {
      const arrayContext = context ? createNestedContext(context, 'array', index) : undefined;
      return resolveValue(item, arrayContext);
    });
  }

  if (value && typeof value === 'object' && value.constructor === Object) {
    const resolved: Record<string, unknown> = {};
    for (const [key, val] of Object.entries(value)) {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      resolved[key] = resolveValue(val, nestedContext);
    }
    return resolved;
  }

  return value;
}

abstract class FluentBuilderBase<T, C extends BaseBuildContext = BaseBuildContext> {
  readonly [FLUENT_BUILDER_SYMBOL] = true;
  protected values: Partial<T> = {};
  protected builders = new Map<string, FluentBuilder<unknown, C> | Array<FluentBuilder<unknown, C>>>();
  protected context?: C;

  constructor(initial?: Partial<T>) {
    if (initial) {
      this.values = { ...initial };
    }
  }

  protected set<K extends keyof T>(key: K, value: unknown): this {
    if (isFluentBuilder(value) || isBuilderArray(value)) {
      this.builders.set(String(key), value);
    } else if (Array.isArray(value)) {
      if (value.some(isFluentBuilder)) {
        this.builders.set(String(key), value);
      } else {
        this.values[key] = value as T[K];
      }
    } else {
      this.values[key] = value as T[K];
    }
    return this;
  }

  protected buildWithDefaults(defaults?: Partial<T>, context?: C): T {
    const result: Record<string, unknown> = defaults ? { ...defaults } : {};

    Object.assign(result, this.values);

    this.builders.forEach((value, key) => {
      const nestedContext = context ? createNestedContext(context, key) : undefined;
      result[key] = resolveValue(value, nestedContext);
    });

    return result as T;
  }

  public if<K extends keyof T>(
    predicate: (builder: this) => boolean,
    property: K,
    value: T[K] | FluentBuilder<T[K], C> | (() => T[K] | FluentBuilder<T[K], C>)
  ): this {
    if (predicate(this)) {
      const resolvedValue = typeof value === 'function' && !isFluentBuilder(value)
        ? (value as () => T[K] | FluentBuilder<T[K], C>)()
        : value;
      this.set(property, resolvedValue);
    }
    return this;
  }

  public has<K extends keyof T>(key: K): boolean {
    return key in this.values || this.builders.has(String(key));
  }

  public peek<K extends keyof T>(key: K): T[K] | undefined {
    return this.values[key];
  }

  abstract build(context?: C): T;
}

function createInspectMethod(builderName: string, properties: Record<string, unknown>): string {
  return \`\${builderName} { properties: \${JSON.stringify(properties, null, 2)} }\`;
}


import type { User, Address } from "./src/__tests__/fixtures/simple.ts";

export interface UserBuilderMethods {
  /** Unique identifier */
  withId(value: string): UserBuilder;
  /** Full name */
  withName(value: string): UserBuilder;
  /** Age in years */
  withAge(value: number): UserBuilder;
  /** User address */
  withAddress(value: Address | FluentBuilder<Address, BaseBuildContext>): UserBuilder;
}

export class UserBuilder extends FluentBuilderBase<User> implements UserBuilderMethods, FluentBuilder<User, BaseBuildContext> {
  private static readonly defaults: Record<string, unknown> = { id: "", name: "" };

  constructor(initial?: Partial<User>) {
    super(initial);
  }

  /** Unique identifier */

  withId(value: string): UserBuilder {
    return this.set("id", value);
  }

  /** Full name */

  withName(value: string): UserBuilder {
    return this.set("name", value);
  }

  /** Age in years */

  withAge(value: number): UserBuilder {
    return this.set("age", value);
  }

  /** User address */

  withAddress(value: Address | FluentBuilder<Address, BaseBuildContext>): UserBuilder {
    return this.set("address", value);
  }

  /**
   * Builds the final User object
   * @param context - Optional build context for nested builders
   */
  build(context?: BaseBuildContext): User {
    return this.buildWithDefaults(UserBuilder.defaults, context);
  }

  [Symbol.for("nodejs.util.inspect.custom")](): string {
    return createInspectMethod("UserBuilder", this.values);
  }
}

/**
 * Creates a new User builder
 * @param initial Optional initial values
 * @returns A fluent builder for User
 */
export function user(initial?: Partial<User>): UserBuilder {
  return new UserBuilder(initial);
}",
}
`;
